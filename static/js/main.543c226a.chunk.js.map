{"version":3,"sources":["assets/thicc-png.png","components/FileInput/FileInput.js","redux/innerCanvasInfoReducer.js","redux/outerCanvasInfoReducer.js","redux/canvasEditReducer.js","components/ColorToggler/ColorToggler.js","utils/ImageAnalysis.js","utils/Canvas.js","components/CanvasEffectButtonGroup/utils.js","components/CanvasEffectButtonGroup/CanvasEffectButtonGroup.js","components/ImageAnalyzer/ImageAnalyzer.js","components/Canvas/Canvas.js","redux/imageReducer.js","redux/combinedCanvasInfoReducer.js","components/AnalysisResults/utils.js","components/AnalysisResults/AnalysisResults.js","components/App/App.js","serviceWorker.js","redux/canvasSettingsReducer.js","redux/index.js","index.js"],"names":["module","exports","setContext","context","type","payload","setDetectedPixels","detectedPixels","setRecolorHex","hex","initialState","recoloredImageData","numColoredPixels","recolorHex","isOuterEdit","ColorToggler","useSelector","state","canvasEdit","dispatch","useDispatch","canvasEditToggler","Button","active","className","variant","onClick","isRed","threshold","r","g","b","isBlue","detect","canvasContext","detectionDimensions","isColor","a","detectionWidth","detectionHeight","imageData","getImageData","hexToRgb","redRecolor","greenRecolor","blueRecolor","originalPixels","data","slice","y","x","redIndex","getIndex","greenIndex","blueIndex","redValue","greenValue","blueValue","Number","push","Promise","resolve","colorAreaWithBounds","outerCanvasInfo","innerCanvasInfo","combinedCanvasInfo","width","height","leftX","rightX","updateImageData","outerNumPixelsColored","innerNumPixelsColored","canvasInfo","getBoundedPixelInfo","numDetectedPixels","existingPixels","isExistingPixel","containsXYKeyIn","getXYKey","window","coordinate","i","currentKey","set","Map","key","String","getKey","map","has","red","green","blue","length","setWithImage","image","drawImage","event","canvasWidth","canvasHeight","setNumPixelsColored","preventDefault","Canvas","CanvasEffectButtonGroup","props","source","currentCanvasInfo","detectionThreshold","canvasSettings","canvasDimensions","isColorDetector","ImageAnalysis","putImageData","outerCanvasInfoReducer","innerCanvasInfoReducer","recolorDetection","setNumColoredPixels","utils","ImageAnalyzer","useState","setDetectionThreshold","changeDetectionThresholdBy","value","previous","newValue","parseInt","innerRecolorHex","outerRecolorHex","canvasColorOptionsProps","Form","Label","Control","onChange","target","min","max","drawDimensions","drawWidth","drawHeight","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","ref","setNumColoredInnerPixels","setNumColoredOuterPixels","numColoredOuterPixels","numColoredInnerPixels","outerDetectedPixels","innerDetectedPixels","findLeftCutOff","findRightCutOff","combinedCanvasInfoReducer","smallestOuter","MAX_SAFE_INTEGER","Math","smallestInner","largestOuter","largestInner","AnalysisResults","outerPixels","outerNumColoredPixels","innerNumColoredPixels","canvasProps","toFixed","videoConstraints","facingMode","exact","audio","imageSmoothing","screenshotQuality","App","innerCanvasContext","outerCanvasContext","outerCanvasProps","setOuterContext","innerCanvasProps","setInnerContext","analysisResultsProps","webcamRef","capture","useCallback","screenshot","getScreenshot","Image","onload","src","style","position","float","screenshotFormat","sample","Boolean","location","hostname","match","rootReducer","combineReducers","action","store","createStore","applyMiddleware","thunk","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.543c226a.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/thicc-png.c9dcc9e1.png\";","import React from \"react\";\nimport { Form } from \"react-bootstrap\";\n\nfunction FileInput(props) {\n  const { label, accept, onChangeHandler } = props;\n  return (\n    <div>\n      <Form.File\n        type=\"file\"\n        accept={accept}\n        label={label}\n        style={inputStyle}\n        custom\n        onChange={(event) => onChangeHandler(event)}\n      />\n    </div>\n  );\n}\n\nconst inputStyle = {\n  width: \"300px\",\n};\n\nexport default FileInput;\n","export function setContext(context) {\n  return { type: \"SET_INNER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_INNER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_INNER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_INNER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_INNER_RECOLOR_HEX\", payload: hex };\n}\n\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#00FF00\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_INNER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_INNER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_INNER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_INNER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_INNER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_OUTER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_OUTER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_OUTER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_OUTER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_OUTER_RECOLOR_HEX\", payload: hex };\n}\n\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#FFA500\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_OUTER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_OUTER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_OUTER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_OUTER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_OUTER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function toggleIsOuterEdit() {\n  return { type: \"TOGGLE_IS_OUTER_EDIT\" };\n}\n\nconst initialState = {\n  isOuterEdit: true,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"TOGGLE_IS_OUTER_EDIT\":\n      return {\n        ...state,\n        isOuterEdit: !state.isOuterEdit,\n      };\n    default:\n      return state;\n  }\n}\n","import { Button } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as canvasEditReducer from \"../../redux/canvasEditReducer\";\nimport React from \"react\";\nfunction ColorToggler() {\n  const isOuterEdit = useSelector((state) => state.canvasEdit.isOuterEdit);\n  const dispatch = useDispatch();\n  const canvasEditToggler = () => {\n    dispatch(canvasEditReducer.toggleIsOuterEdit());\n  };\n  return (\n    <div>\n      <div>Currently editing:</div>\n      <Button\n        active={isOuterEdit}\n        className=\"mr-2\"\n        variant=\"outline-danger\"\n        onClick={canvasEditToggler}\n      >\n        Outer\n      </Button>\n      <Button\n        active={!isOuterEdit}\n        variant=\"outline-primary\"\n        onClick={canvasEditToggler}\n      >\n        Inner\n      </Button>\n    </div>\n  );\n}\n\nexport default ColorToggler;\n","import Color from \"color\";\n\n/**\n * Basic algorithm for red detection\n * @param {*} threshold\n */\nfunction isRed(threshold) {\n  return (r, g, b) => r * 2 - (g + b) > 255 - threshold;\n}\n\n/**\n * Basic algorithm for blue detection\n * @param {*} threshold\n */\nfunction isBlue(threshold) {\n  return (r, g, b) => b * 2 - (g + r) > 255 - threshold;\n}\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n/**\n * Detects the color, recolors it, and return the newly recolored image / number of pixels colored\n * @param {*} detectionDimensions\n * @param {*} imageData\n * @param {*} isColor\n * @param {*} recolorHex\n */\nasync function detect(canvasContext, detectionDimensions, isColor, recolorHex) {\n  const { detectionWidth, detectionHeight } = detectionDimensions;\n  const imageData = canvasContext.getImageData(\n    0,\n    0,\n    detectionWidth,\n    detectionHeight\n  );\n\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(recolorHex);\n  const detectedPixels = [];\n  const originalPixels = imageData.data.slice();\n\n  for (let y = 0; y < detectionHeight / 2; y++) {\n    for (let x = 0; x < detectionWidth; x++) {\n      const redIndex = getIndex(x, y, detectionWidth) + R_OFFSET;\n      const greenIndex = getIndex(x, y, detectionWidth) + G_OFFSET;\n      const blueIndex = getIndex(x, y, detectionWidth) + B_OFFSET;\n\n      const redValue = originalPixels[redIndex];\n      const greenValue = originalPixels[greenIndex];\n      const blueValue = originalPixels[blueIndex];\n\n      if (isColor(redValue, greenValue, blueValue)) {\n        imageData.data[redIndex] = Number(redRecolor);\n        imageData.data[greenIndex] = Number(greenRecolor);\n        imageData.data[blueIndex] = Number(blueRecolor);\n        detectedPixels.push({ x: x, y: y });\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, detectedPixels]);\n}\n\n/**\n * Color the canvas area and return how many detected pixels there are\n * @param {*} param0\n * @param {*} canvasContext\n * @param {*} newColorHex\n * @param {*} detectedPixels\n */\nasync function colorArea(\n  { width, height },\n  canvasContext,\n  newColorHex,\n  detectedPixels\n) {\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(newColorHex);\n  const imageData = canvasContext.getImageData(0, 0, width, height);\n  let numPixelsColored = 0;\n\n  const { numDetectedPixels, maxY, existingPixels } = getPixelInfo(\n    detectedPixels\n  );\n  numPixelsColored += numDetectedPixels;\n\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    for (let i = y; i < maxY; i++) {\n      if (!isExistingPixel(x, i)) {\n        const redIndex = getIndex(x, i, width) + R_OFFSET;\n        const greenIndex = getIndex(x, i, width) + G_OFFSET;\n        const blueIndex = getIndex(x, i, width) + B_OFFSET;\n        imageData.data[redIndex] = redRecolor;\n        imageData.data[greenIndex] = greenRecolor;\n        imageData.data[blueIndex] = blueRecolor;\n\n        const key = getXYKey(x, i);\n        existingPixels.set(key, null);\n        numPixelsColored++;\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, numPixelsColored]);\n}\n\nasync function colorAreaWithBounds(\n  { width, height },\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  { leftX, rightX }\n) {\n  const imageData = combinedCanvasInfo.context.getImageData(\n    0,\n    0,\n    width,\n    height\n  );\n\n  const outerNumPixelsColored = await updateImageData(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    outerCanvasInfo\n  );\n\n  const innerNumPixelsColored = await updateImageData(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    innerCanvasInfo\n  );\n\n  return Promise.resolve({\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  });\n}\n\nasync function updateImageData(\n  { width, height },\n  imageData,\n  { leftX, rightX },\n  canvasInfo\n) {\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(\n    canvasInfo.recolorHex\n  );\n\n  let {\n    numDetectedPixels,\n    existingPixels,\n  } = getBoundedPixelInfo(canvasInfo.detectedPixels, { leftX, rightX });\n\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  window.existingPixels = existingPixels;\n\n  for (let [, coordinate] of existingPixels) {\n    if (coordinate != null) {\n      const { x, y } = coordinate;\n\n      for (let i = y; i < height / 2; i++) {\n        if (!isExistingPixel(x, i)) {\n          const redIndex = getIndex(x, i, width) + R_OFFSET;\n          const greenIndex = getIndex(x, i, width) + G_OFFSET;\n          const blueIndex = getIndex(x, i, width) + B_OFFSET;\n          imageData.data[redIndex] = redRecolor;\n          imageData.data[greenIndex] = greenRecolor;\n          imageData.data[blueIndex] = blueRecolor;\n\n          const currentKey = getXYKey(x, i);\n          existingPixels.set(currentKey, null);\n          numDetectedPixels++;\n        }\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\nfunction getBoundedPixelInfo(detectedPixels, { leftX, rightX }) {\n  const existingPixels = new Map();\n\n  let numDetectedPixels = 0;\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    if (x >= leftX && x <= rightX) {\n      const key = getXYKey(x, y);\n      existingPixels.set(key, coordinate);\n      numDetectedPixels++;\n    }\n  }\n\n  return {\n    numDetectedPixels,\n    existingPixels,\n  };\n}\n\nfunction getPixelInfo(detectedPixels) {\n  const existingPixels = new Map();\n\n  let numDetectedPixels = 0;\n  let maxY = 0;\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    maxY = Math.max(y, maxY);\n    const key = getXYKey(x, y);\n    existingPixels.set(key, null);\n    numDetectedPixels++;\n  }\n\n  return {\n    numDetectedPixels,\n    existingPixels,\n    maxY,\n  };\n}\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} hex\n */\nfunction hexToRgb(hex) {\n  let red = 0,\n    green = 0,\n    blue = 0;\n  if (hex.length == 4) {\n    red = \"0x\" + hex[1] + hex[1];\n    green = \"0x\" + hex[2] + hex[2];\n    blue = \"0x\" + hex[3] + hex[3];\n  } else if (hex.length == 7) {\n    red = \"0x\" + hex[1] + hex[2];\n    green = \"0x\" + hex[3] + hex[4];\n    blue = \"0x\" + hex[5] + hex[6];\n  }\n  return [red, green, blue];\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\nexport { detect, colorArea, isRed, isBlue, colorAreaWithBounds };\n","// TODO to be implemented / fixed!\n\nconst WIDTH_PADDING = 50;\n\nasync function drawRotated(context, canvas, degrees, image) {\n  if (canvas == null || image == null || context == null) {\n    return;\n  }\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.save();\n  context.translate(canvas.width / 2, canvas.height / 2);\n  context.rotate(degreesToRadians(degrees));\n\n  const width = window.innerWidth - WIDTH_PADDING;\n  const height = (image.height / width) * width;\n  context.drawImage(image, -width / 2, -height / 2);\n  context.restore();\n}\n\nfunction drawAxis(context, canvas, axisCoordinates, image) {\n  if (canvas == null || image == null) {\n    return;\n  }\n  const { x: xOffset, y: yOffset } = axisCoordinates;\n  const { width: canvasWidth, height: canvasHeight } = canvas;\n  const originX = 0;\n  const originY = canvasHeight / 2 + yOffset;\n  context.beginPath();\n  context.moveTo(originX, originY + yOffset);\n  context.lineTo(originX + canvasWidth, originY + yOffset);\n  context.strokeStyle = \"#FF0000\";\n  context.stroke();\n}\n\nfunction degreesToRadians(degrees) {\n  return degrees * 0.01745;\n}\n\nfunction clearCanvasDrawing(context, width, height) {\n  if (context == null) {\n    return;\n  }\n  context.clearRect(0, 0, width, height);\n}\n\nfunction setWithImage(context, width, height, image) {\n  if (context == null) {\n    return;\n  }\n  context.drawImage(image, 0, 0, width, height);\n}\n\nexport { drawRotated, drawAxis, clearCanvasDrawing, setWithImage };\n","import * as Canvas from \"../../utils/Canvas\";\n\nasync function resetCanvas(\n  event,\n  canvasContext,\n  canvasWidth,\n  canvasHeight,\n  image,\n  setNumPixelsColored\n) {\n  event.preventDefault();\n  Canvas.setWithImage(canvasContext, canvasWidth, canvasHeight, image);\n  setNumPixelsColored(0);\n}\n\nexport { resetCanvas };\n","import React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { Button } from \"react-bootstrap\";\nimport * as innerCanvasInfoReducer from \"../../redux/innerCanvasInfoReducer\";\nimport * as outerCanvasInfoReducer from \"../../redux/outerCanvasInfoReducer\";\nimport * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as utils from \"./utils\";\n\nfunction CanvasEffectButtonGroup(props) {\n  const dispatch = useDispatch();\n  const image = useSelector((state) => state.image.source);\n  const isOuterEdit = useSelector((state) => state.canvasEdit.isOuterEdit);\n  const outerCanvasInfo = useSelector((state) => state.outerCanvasInfo);\n  const innerCanvasInfo = useSelector((state) => state.innerCanvasInfo);\n  const currentCanvasInfo = isOuterEdit ? outerCanvasInfo : innerCanvasInfo;\n\n  const { recolorHex } = props;\n  const [detectionThreshold] = props.detectionThreshold;\n  const { width: canvasWidth, height: canvasHeight } = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  // TODO move this to utils\n  async function recolorDetection(event, canvasContext) {\n    event.preventDefault();\n    const { width: detectionWidth, height: detectionHeight } = image;\n    const detectionDimensions = { detectionWidth, detectionHeight };\n\n    const isColorDetector = isOuterEdit\n      ? ImageAnalysis.isRed(detectionThreshold)\n      : ImageAnalysis.isBlue(detectionThreshold);\n\n    const [recoloredImageData, detectedPixels] = await ImageAnalysis.detect(\n      canvasContext,\n      detectionDimensions,\n      isColorDetector,\n      recolorHex\n    );\n\n    canvasContext.putImageData(\n      recoloredImageData,\n      0,\n      0,\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n\n    const setContext = isOuterEdit\n      ? outerCanvasInfoReducer.setContext\n      : innerCanvasInfoReducer.setContext;\n    dispatch(setContext(canvasContext));\n\n    const setDetectedPixels = isOuterEdit\n      ? outerCanvasInfoReducer.setDetectedPixels\n      : innerCanvasInfoReducer.setDetectedPixels;\n    dispatch(setDetectedPixels(detectedPixels));\n  }\n\n  return (\n    <div>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={(event) => recolorDetection(event, currentCanvasInfo.context)}\n      >\n        Recolor detected\n      </Button>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={(event) => {\n          const setNumPixelsColored = isOuterEdit\n            ? outerCanvasInfoReducer.setNumColoredPixelsCallback(dispatch)\n            : innerCanvasInfoReducer.setNumColoredPixelsCallback(dispatch);\n\n          const setDetectedPixels = isOuterEdit\n            ? outerCanvasInfoReducer.setDetectedPixels\n            : innerCanvasInfoReducer.setDetectedPixels;\n          dispatch(setDetectedPixels([]));\n\n          utils.resetCanvas(\n            event,\n            currentCanvasInfo.context,\n            canvasWidth,\n            canvasHeight,\n            image,\n            setNumPixelsColored\n          );\n        }}\n      >\n        Reset\n      </Button>\n    </div>\n  );\n}\n\nexport default CanvasEffectButtonGroup;\n","import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { Form, Button } from \"react-bootstrap\";\nimport * as innerCanvasInfoReducer from \"../../redux/innerCanvasInfoReducer\";\nimport * as outerCanvasInfoReducer from \"../../redux/outerCanvasInfoReducer\";\nimport ColorToggler from \"../ColorToggler/ColorToggler\";\nimport CanvasEffectButtonGroup from \"../CanvasEffectButtonGroup/CanvasEffectButtonGroup\";\nimport \"./index.css\";\n\nfunction ImageAnalyzer(props) {\n  const dispatch = useDispatch();\n  const SLIDER_MIN = 0;\n  const SLIDER_MAX = 255;\n  const [detectionThreshold, setDetectionThreshold] = useState(0);\n\n  const changeDetectionThresholdBy = (value) => {\n    setDetectionThreshold((previous) => {\n      previous = parseInt(previous);\n      let newValue = previous + value;\n      newValue = newValue < 0 ? SLIDER_MIN : newValue;\n      newValue = newValue > SLIDER_MAX ? SLIDER_MAX : newValue;\n      return newValue;\n    });\n  };\n\n  const isOuterEdit = useSelector((state) => state.canvasEdit.isOuterEdit);\n\n  const innerSetRecolorHex = innerCanvasInfoReducer.setRecolorHex;\n  const outerSetRecolorHex = outerCanvasInfoReducer.setRecolorHex;\n  const setRecolorHex = isOuterEdit ? outerSetRecolorHex : innerSetRecolorHex;\n\n  const innerRecolorHex = useSelector(\n    (state) => state.innerCanvasInfo.recolorHex\n  );\n\n  const outerRecolorHex = useSelector(\n    (state) => state.outerCanvasInfo.recolorHex\n  );\n  const recolorHex = isOuterEdit ? outerRecolorHex : innerRecolorHex;\n\n  const canvasColorOptionsProps = {\n    detectionThreshold: [detectionThreshold, setDetectionThreshold],\n    ...props,\n    recolorHex,\n  };\n\n  return (\n    <div>\n      <div>\n        <ColorToggler />\n      </div>\n      <div>\n        <Form.Label>Recolor:</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"color\"\n          value={recolorHex}\n          onChange={(event) => {\n            const { value } = event.target;\n            dispatch(setRecolorHex(value));\n          }}\n        />\n      </div>\n      <div>\n        <Form.Label>Sensitivity: {detectionThreshold}</Form.Label>\n        <div className=\"d-flex mx-auto justify-content-center\">\n          <Button\n            onClick={(event) => {\n              event.preventDefault();\n              changeDetectionThresholdBy(-15);\n            }}\n            variant=\"outline-primary\"\n          >\n            -15\n          </Button>\n          <Button\n            className=\"mx-2\"\n            onClick={(event) => {\n              event.preventDefault();\n              changeDetectionThresholdBy(-5);\n            }}\n            variant=\"outline-primary\"\n          >\n            -5\n          </Button>\n          <Form.Control\n            className=\"input mx-2\"\n            type=\"range\"\n            min={SLIDER_MIN}\n            max={SLIDER_MAX}\n            value={detectionThreshold}\n            onChange={(event) => setDetectionThreshold(event.target.value)}\n          />\n          <Button\n            className=\"mx-2\"\n            onClick={(event) => {\n              event.preventDefault();\n              changeDetectionThresholdBy(5);\n            }}\n            variant=\"outline-primary\"\n          >\n            +5\n          </Button>\n          <Button\n            onClick={(event) => {\n              event.preventDefault();\n              changeDetectionThresholdBy(15);\n            }}\n            variant=\"outline-primary\"\n          >\n            +15\n          </Button>\n        </div>\n      </div>\n      <div className=\"m-2\">\n        <CanvasEffectButtonGroup {...canvasColorOptionsProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default ImageAnalyzer;\n","import React, { useEffect, useRef } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const dispatch = useDispatch();\n  const image = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    dispatch(setCanvasContext(context));\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null || canvasRef == null) {\n      return;\n    }\n\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image, drawWidth, drawHeight, canvasWidth, canvasHeight, canvasContext]);\n\n  return (\n    <div>\n      <canvas ref={canvasRef} className=\"border\" />\n    </div>\n  );\n}\n\nexport default Canvas;\n","export function setImage(source) {\n  return (dispatch) => {\n    const image = new Image();\n    image.onload = () => {\n      dispatch({ type: \"IMAGE_SET\", payload: image });\n    };\n    image.src = source;\n  };\n}\n\nexport function setImageCallback(dispatch) {\n  return (image) => {\n    dispatch({\n      type: \"IMAGE_SET\",\n      payload: image,\n    });\n  };\n}\n\nconst initialState = {\n  source: null,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"IMAGE_SET\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_COMBINE_CONTEXT\", payload: context };\n}\nexport function setNumColoredInnerPixels(context) {\n  return { type: \"SET_NUM_COLORED_INNER_PIXELS\", payload: context };\n}\nexport function setNumColoredOuterPixels(context) {\n  return { type: \"SET_NUM_COLORED_OUTER_PIXELS\", payload: context };\n}\nconst initialState = {\n  context: null,\n  numColoredOuterPixels: 0,\n  numColoredInnerPixels: 0,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_COMBINE_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_NUM_COLORED_INNER_PIXELS\":\n      return {\n        ...state,\n        numColoredInnerPixels: action.payload,\n      };\n    case \"SET_NUM_COLORED_OUTER_PIXELS\":\n      return {\n        ...state,\n        numColoredOuterPixels: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","import * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\n\nfunction calculatedLossPercent(outerPixels, innerPixels) {\n  let percentage = (100 * (outerPixels - innerPixels)) / outerPixels;\n  return percentage.toFixed(4);\n}\n\nasync function combinedAnalysis(\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  canvasDimensions,\n  dispatch\n) {\n  const outerDetectedPixels = outerCanvasInfo.detectedPixels;\n  const innerDetectedPixels = innerCanvasInfo.detectedPixels;\n  const leftX = await findLeftCutOff(outerDetectedPixels, innerDetectedPixels);\n  const rightX = await findRightCutOff(\n    outerDetectedPixels,\n    innerDetectedPixels\n  );\n\n  const {\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  } = await ImageAnalysis.colorAreaWithBounds(\n    canvasDimensions,\n    outerCanvasInfo,\n    innerCanvasInfo,\n    combinedCanvasInfo,\n    { leftX, rightX }\n  );\n\n  combinedCanvasInfo.context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    canvasDimensions.width,\n    canvasDimensions.height\n  );\n  dispatch(combinedCanvasInfoReducer.setContext(combinedCanvasInfo.context));\n\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredInnerPixels(innerNumPixelsColored)\n  );\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredOuterPixels(outerNumPixelsColored)\n  );\n}\n\nasync function findLeftCutOff(outerDetectedPixels, innerDetectedPixels) {\n  let smallestOuter = Number.MAX_SAFE_INTEGER;\n  for (let coordinate of outerDetectedPixels) {\n    const { x } = coordinate;\n    smallestOuter = Math.min(smallestOuter, x);\n  }\n\n  let smallestInner = Number.MAX_SAFE_INTEGER;\n  for (let coordinate of innerDetectedPixels) {\n    const { x } = coordinate;\n    smallestInner = Math.min(smallestInner, x);\n  }\n\n  return Math.max(smallestOuter, smallestInner);\n}\nasync function findRightCutOff(outerDetectedPixels, innerDetectedPixels) {\n  let largestOuter = 0;\n  for (let coordinate of outerDetectedPixels) {\n    const { x } = coordinate;\n    largestOuter = Math.max(largestOuter, x);\n  }\n\n  let largestInner = 0;\n  for (let coordinate of innerDetectedPixels) {\n    const { x } = coordinate;\n    largestInner = Math.max(largestInner, x);\n  }\n\n  return Math.min(largestOuter, largestInner);\n}\n\nexport { calculatedLossPercent, combinedAnalysis };\n","import React from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\n\nfunction AnalysisResults(props) {\n  const dispatch = useDispatch();\n\n  const outerCanvasInfo = useSelector((state) => state.outerCanvasInfo);\n  const innerCanvasInfo = useSelector((state) => state.innerCanvasInfo);\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  const outerNumColoredPixels = combinedCanvasInfo.numColoredOuterPixels;\n  const innerNumColoredPixels = combinedCanvasInfo.numColoredInnerPixels;\n\n  const canvasProps = {\n    ...props,\n    canvasContext: [\n      combinedCanvasInfo.context,\n      combinedCanvasInfoReducer.setContext,\n    ],\n  };\n\n  return (\n    <div>\n      <Canvas {...canvasProps} />\n      <Button\n        className=\"my-2\"\n        variant=\"outline-primary\"\n        onClick={() => {\n          utils.combinedAnalysis(\n            outerCanvasInfo,\n            innerCanvasInfo,\n            combinedCanvasInfo,\n            canvasDimensions,\n            dispatch\n          );\n        }}\n      >\n        Recolor\n      </Button>\n      <div>\n        <div>Outer pixel count: {outerNumColoredPixels}</div>\n        <div>Inner pixel count: {innerNumColoredPixels}</div>\n        <div>\n          Calculated Loss %:{\" \"}\n          {utils.calculatedLossPercent(\n            outerNumColoredPixels,\n            innerNumColoredPixels\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default AnalysisResults;\n","import React, { useRef, useCallback, useEffect } from \"react\";\nimport { Button, Card, Accordion } from \"react-bootstrap\";\nimport FileInput from \"../FileInput/FileInput\";\nimport ImageAnalyzer from \"../ImageAnalyzer/ImageAnalyzer\";\nimport * as utils from \"./utils\";\nimport Canvas from \"../Canvas/Canvas\";\nimport Webcam from \"react-webcam\";\nimport * as imageReducer from \"../../redux/imageReducer\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { setContext as setInnerContext } from \"../../redux/innerCanvasInfoReducer\";\nimport { setContext as setOuterContext } from \"../../redux/outerCanvasInfoReducer\";\nimport AnalysisResults from \"../AnalysisResults/AnalysisResults\";\n\nimport \"./App.css\";\nimport sample from \"../../assets/thicc-png.png\";\n\nconst WIDTH = 450;\nconst HEIGHT = 370;\n\n// TODO this same as canvas dimensions in canvas settings\nconst videoConstraints = {\n  width: WIDTH,\n  height: HEIGHT,\n  facingMode: { exact: \"environment\" },\n  // facingMode: \"user\",\n  audio: false,\n  imageSmoothing: true,\n  screenshotQuality: 1,\n};\n\nfunction App() {\n  const dispatch = useDispatch();\n  const image = useSelector((state) => state.image.source);\n\n  const innerCanvasContext = useSelector(\n    (state) => state.innerCanvasInfo.context\n  );\n  const outerCanvasContext = useSelector(\n    (state) => state.outerCanvasInfo.context\n  );\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  const outerCanvasProps = {\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n    canvasContext: [outerCanvasContext, setOuterContext],\n  };\n\n  const innerCanvasProps = {\n    ...outerCanvasProps,\n    canvasContext: [innerCanvasContext, setInnerContext],\n  };\n\n  const analysisResultsProps = {\n    ...innerCanvasProps,\n  };\n\n  const webcamRef = useRef(null);\n  const capture = useCallback(() => {\n    const screenshot = webcamRef.current.getScreenshot();\n    dispatch(imageReducer.setImage(screenshot));\n  }, [webcamRef]);\n\n  return (\n    <div className=\"App\">\n      <h4>Welcome to P-calc</h4>\n\n      <div style={{ position: \"relative\", float: \"top\" }}>\n        <Webcam\n          audio={false}\n          height={HEIGHT}\n          ref={webcamRef}\n          screenshotFormat=\"image/jpeg\"\n          width={WIDTH}\n          videoConstraints={videoConstraints}\n        />\n        <div className=\"overlay\">\n          <img src={sample} />\n        </div>\n      </div>\n\n      {/* <span\n            className=\"cross\"\n            style={{\n              position: \"absolute\",\n              top: HEIGHT / 2 + 2,\n              right: 0,\n              bottom: HEIGHT / 2 + 2,\n              left: 0,\n              backgroundColor: \"red\",\n            }}\n          ></span>\n\n          <span\n            className=\"circle\"\n            style={{\n              position: \"absolute\",\n              top: 0,\n              right: 0,\n              bottom: 0,\n              left: 0,\n            }}\n          ></span>\n\n          <span\n            style={{\n              position: \"absolute\",\n              top: HEIGHT / 2 + 2,\n              right: 0,\n              bottom: HEIGHT / 2 + 2,\n              left: 0,\n              backgroundColor: \"red\",\n            }}\n          ></span> */}\n\n      <div className=\"my-3\">\n        <Button onClick={capture} variant=\"outline-primary\">\n          Take picture\n        </Button>\n      </div>\n\n      <Canvas {...outerCanvasProps} />\n      <Canvas {...innerCanvasProps} />\n      <ImageAnalyzer />\n\n      <div>\n        <AnalysisResults {...analysisResultsProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export function setCanvasDimensions(dimensions) {\n  return { type: \"SET_CANVAS_DIMENSIONS\", payload: dimensions };\n}\n\nconst initialState = {\n  canvasDimensions: {\n    width: 400,\n    height: 400,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_CANVAS_DIMENSIONS\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","import { combineReducers, createStore, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport imageReducer from \"./imageReducer\";\nimport canvasEditReducer from \"./canvasEditReducer\";\nimport innerCanvasInfoReducer from \"./innerCanvasInfoReducer\";\nimport outerCanvasInfoReducer from \"./outerCanvasInfoReducer\";\nimport combinedCanvasInfoReducer from \"./combinedCanvasInfoReducer\";\nimport canvasSettingsReducer from \"./canvasSettingsReducer\";\n\nconst rootReducer = combineReducers({\n  image: imageReducer,\n  canvasEdit: canvasEditReducer,\n  innerCanvasInfo: innerCanvasInfoReducer,\n  outerCanvasInfo: outerCanvasInfoReducer,\n  combinedCanvasInfo: combinedCanvasInfoReducer,\n  canvasSettings: canvasSettingsReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"../src/components/App/App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Provider } from \"react-redux\";\nimport store from \"./redux\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}