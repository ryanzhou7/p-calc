{"version":3,"sources":["components/FileInput/FileInput.js","utils/DomHelper.js","utils/ImageAnalysis.js","components/ColorToggler/ColorToggler.js","utils/Canvas.js","components/ImageAnalyzer/resetCanvas.js","components/ImageAnalyzer/ImageAnalyzer.js","components/Canvas/Canvas.js","App.js","serviceWorker.js","index.js"],"names":["inputStyle","width","FileInput","props","label","accept","onChangeHandler","Form","File","type","style","custom","onChange","event","getImageFromInput","a","Promise","resolve","reject","target","files","item","imageSource","URL","createObjectURL","image","Image","onload","src","isRed","threshold","r","g","b","isBlue","detect","detectionDimensions","imageData","isColor","recolorHex","detectionWidth","detectionHeight","hexToRgb","redRecolor","greenRecolor","blueRecolor","detectedPixels","originalPixels","data","slice","y","x","redIndex","getIndex","greenIndex","blueIndex","redValue","greenValue","blueValue","Number","push","colorArea","canvasContext","newColorHex","height","getImageData","numPixelsColored","maxY","existingPixels","Map","isExistingPixel","containsXYKeyIn","getXYKey","coordinate","Math","max","key","set","i","String","getKey","map","has","hex","red","green","blue","length","ColorToggler","isRedEdit","setIsRedEdit","redToggler","prev","Button","active","className","variant","onClick","setWithImage","context","drawImage","canvasWidth","canvasHeight","setNumPixelsColored","preventDefault","Canvas","resetCanvas","ImageAnalyzer","canvasDimensions","useState","detectionThreshold","setDetectionThreshold","numPixelsColoredRed","setNumPixelsColoredRed","numPixelsColoredBlue","setNumPixelsColoredBlue","setDetectedPixels","setRecolorHex","isColorDetector","ImageAnalysis","recoloredImageData","putImageData","numPixels","Label","Control","value","setter","DomHelper","min","recolorDetection","recolorCanvasArea","drawDimensions","drawWidth","drawHeight","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","ref","App","setImage","canvasContextRed","setCanvasContextRed","canvasContextBlue","setCanvasContextBlue","setCanvasDimensions","saveSelectedImage","currentCanvasContext","Accordion","defaultActiveKey","Card","Header","Toggle","as","eventKey","Collapse","Body","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7179c29c.chunk.js","sourcesContent":["import React from \"react\";\nimport { Form } from \"react-bootstrap\";\n\nfunction FileInput(props) {\n  const { label, accept, onChangeHandler } = props;\n  return (\n    <div>\n      <Form.File\n        type=\"file\"\n        accept={accept}\n        label={label}\n        style={inputStyle}\n        custom\n        onChange={(event) => onChangeHandler(event)}\n      />\n    </div>\n  );\n}\n\nconst inputStyle = {\n  width: \"300px\",\n};\n\nexport default FileInput;\n","/**\n * Return the image with it's source loaded from an file input\n * @param {*} event\n */\nasync function getImageFromInput(event) {\n  return new Promise((resolve, reject) => {\n    if (event.target.files && event.target.files.item(0)) {\n      const imageSource = URL.createObjectURL(event.target.files[0]);\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.src = imageSource;\n      return;\n    }\n    reject(\"No file selected\");\n  });\n}\n\nfunction setFromInput(event, setter) {\n  const { value } = event.target;\n  setter(value);\n}\n\nexport { getImageFromInput, setFromInput };\n","/**\n * Basic algorithm for red detection\n * @param {*} threshold\n */\nfunction isRed(threshold) {\n  return (r, g, b) => r * 2 - (g + b) > threshold;\n}\n\n/**\n * Basic algorithm for blue detection\n * @param {*} threshold\n */\nfunction isBlue(threshold) {\n  return (r, g, b) => b * 2 - (g + r) > threshold;\n}\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n/**\n * Detects the color, recolors it, and return the newly recolored image / number of pixels colored\n * @param {*} detectionDimensions\n * @param {*} imageData\n * @param {*} isColor\n * @param {*} recolorHex\n */\nasync function detect(detectionDimensions, imageData, isColor, recolorHex) {\n  const { detectionWidth, detectionHeight } = detectionDimensions;\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(recolorHex);\n  const detectedPixels = [];\n\n  const originalPixels = imageData.data.slice();\n\n  for (let y = 0; y < detectionHeight; y++) {\n    for (let x = 0; x < detectionWidth; x++) {\n      const redIndex = getIndex(x, y, detectionWidth) + R_OFFSET;\n      const greenIndex = getIndex(x, y, detectionWidth) + G_OFFSET;\n      const blueIndex = getIndex(x, y, detectionWidth) + B_OFFSET;\n\n      const redValue = originalPixels[redIndex];\n      const greenValue = originalPixels[greenIndex];\n      const blueValue = originalPixels[blueIndex];\n\n      if (isColor(redValue, greenValue, blueValue)) {\n        imageData.data[redIndex] = Number(redRecolor);\n        imageData.data[greenIndex] = Number(greenRecolor);\n        imageData.data[blueIndex] = Number(blueRecolor);\n        detectedPixels.push({ x: x, y: y });\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, detectedPixels]);\n}\n\n/**\n * Color the canvas area and return how many detected pixels there are\n * @param {*} param0\n * @param {*} canvasContext\n * @param {*} newColorHex\n * @param {*} detectedPixels\n */\nasync function colorArea(\n  { width, height },\n  canvasContext,\n  newColorHex,\n  detectedPixels\n) {\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(newColorHex);\n  const imageData = canvasContext.getImageData(0, 0, width, height);\n  let numPixelsColored = 0;\n  let maxY = 0;\n\n  const existingPixels = new Map();\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    maxY = Math.max(y, maxY);\n    const key = getXYKey(x, y);\n    existingPixels.set(key, null);\n    numPixelsColored++;\n  }\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    for (let i = y; i < maxY; i++) {\n      if (!isExistingPixel(x, i)) {\n        const redIndex = getIndex(x, i, width) + R_OFFSET;\n        const greenIndex = getIndex(x, i, width) + G_OFFSET;\n        const blueIndex = getIndex(x, i, width) + B_OFFSET;\n        imageData.data[redIndex] = redRecolor;\n        imageData.data[greenIndex] = greenRecolor;\n        imageData.data[blueIndex] = blueRecolor;\n\n        const key = getXYKey(x, i);\n        existingPixels.set(key, null);\n        numPixelsColored++;\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, numPixelsColored]);\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} hex\n */\nfunction hexToRgb(hex) {\n  let red = 0,\n    green = 0,\n    blue = 0;\n  if (hex.length == 4) {\n    red = \"0x\" + hex[1] + hex[1];\n    green = \"0x\" + hex[2] + hex[2];\n    blue = \"0x\" + hex[3] + hex[3];\n  } else if (hex.length == 7) {\n    red = \"0x\" + hex[1] + hex[2];\n    green = \"0x\" + hex[3] + hex[4];\n    blue = \"0x\" + hex[5] + hex[6];\n  }\n  return [red, green, blue];\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n\nexport { detect, colorArea, isRed, isBlue };\n","import { Button } from \"react-bootstrap\";\nimport React from \"react\";\nfunction ColorToggler(props) {\n  const [isRedEdit, setIsRedEdit] = props.isRedEdit;\n  const redToggler = () => {\n    setIsRedEdit((prev) => !prev);\n  };\n  return (\n    <div>\n      <div>Currently editing:</div>\n      <Button\n        active={isRedEdit}\n        className=\"mr-2\"\n        variant=\"outline-danger\"\n        onClick={redToggler}\n      >\n        Red\n      </Button>\n      <Button\n        active={!isRedEdit}\n        variant=\"outline-primary\"\n        onClick={redToggler}\n      >\n        Blue\n      </Button>\n    </div>\n  );\n}\n\nexport default ColorToggler;\n","// TODO to be implemented / fixed!\n\nconst WIDTH_PADDING = 50;\n\nasync function drawRotated(context, canvas, degrees, image) {\n  if (canvas == null || image == null || context == null) {\n    return;\n  }\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.save();\n  context.translate(canvas.width / 2, canvas.height / 2);\n  context.rotate(degreesToRadians(degrees));\n\n  const width = window.innerWidth - WIDTH_PADDING;\n  const height = (image.height / width) * width;\n  context.drawImage(image, -width / 2, -height / 2);\n  context.restore();\n}\n\nfunction drawAxis(context, canvas, axisCoordinates, image) {\n  if (canvas == null || image == null) {\n    return;\n  }\n  const { x: xOffset, y: yOffset } = axisCoordinates;\n  const { width: canvasWidth, height: canvasHeight } = canvas;\n  const originX = 0;\n  const originY = canvasHeight / 2 + yOffset;\n  context.beginPath();\n  context.moveTo(originX, originY + yOffset);\n  context.lineTo(originX + canvasWidth, originY + yOffset);\n  context.strokeStyle = \"#FF0000\";\n  context.stroke();\n}\n\nfunction degreesToRadians(degrees) {\n  return degrees * 0.01745;\n}\n\nfunction clearCanvasDrawing(context, width, height) {\n  if (context == null) {\n    return;\n  }\n  context.clearRect(0, 0, width, height);\n}\n\nfunction setWithImage(context, width, height, image) {\n  if (context == null) {\n    return;\n  }\n  context.drawImage(image, 0, 0, width, height);\n}\n\nexport { drawRotated, drawAxis, clearCanvasDrawing, setWithImage };\n","import * as Canvas from \"../../utils/Canvas\";\n\nasync function resetCanvas(\n  event,\n  canvasContext,\n  canvasWidth,\n  canvasHeight,\n  image,\n  setNumPixelsColored\n) {\n  event.preventDefault();\n  Canvas.setWithImage(canvasContext, canvasWidth, canvasHeight, image);\n  setNumPixelsColored(0);\n}\n\nexport default resetCanvas;\n","import React, { useState } from \"react\";\nimport { Button, Form } from \"react-bootstrap\";\nimport * as DomHelper from \"../../utils/DomHelper\";\nimport * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport ColorToggler from \"../ColorToggler/ColorToggler\";\nimport resetCanvas from \"./resetCanvas\"; // TODO: Review this kind of refactoring/abstraction with Ryan\nimport \"./index.css\";\n\nfunction ImageAnalyzer(props) {\n  const [isRedEdit] = props.isRedEdit;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const [image] = props.image;\n  const [detectionThreshold, setDetectionThreshold] = useState(0);\n  const [numPixelsColoredRed, setNumPixelsColoredRed] = useState(0);\n  const [numPixelsColoredBlue, setNumPixelsColoredBlue] = useState(0);\n  const [canvasContext] = props.canvasContext;\n  const [detectedPixels, setDetectedPixels] = useState([]);\n  const [recolorHex, setRecolorHex] = useState(\"#00FF00\");\n\n  async function recolorDetection() {\n    const { width: detectionWidth, height: detectionHeight } = image;\n    const detectionDimensions = { detectionWidth, detectionHeight };\n    const imageData = canvasContext.getImageData(\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n\n    const isColorDetector = isRedEdit\n      ? ImageAnalysis.isRed(detectionThreshold)\n      : ImageAnalysis.isBlue(detectionThreshold);\n\n    const [recoloredImageData, detectedPixels] = await ImageAnalysis.detect(\n      detectionDimensions,\n      imageData,\n      isColorDetector,\n      recolorHex\n    );\n\n    canvasContext.putImageData(\n      recoloredImageData,\n      0,\n      0,\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n    setDetectedPixels(detectedPixels);\n  }\n\n  async function recolorCanvasArea() {\n    const [imageData, numPixels] = await ImageAnalysis.colorArea(\n      image,\n      canvasContext,\n      recolorHex,\n      detectedPixels\n    );\n    const setNumPixelsColored = isRedEdit\n      ? setNumPixelsColoredRed\n      : setNumPixelsColoredBlue;\n    setNumPixelsColored(numPixels);\n    canvasContext.putImageData(\n      imageData,\n      0,\n      0,\n      0,\n      0,\n      canvasWidth,\n      canvasHeight\n    );\n  }\n\n  return (\n    <div>\n      <div>\n        <ColorToggler isRedEdit={props.isRedEdit} />\n      </div>\n      <div>\n        <Form.Label>Recolor:</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"color\"\n          value={recolorHex}\n          onChange={(event) => DomHelper.setFromInput(event, setRecolorHex)}\n        />\n      </div>\n      <div>\n        <Form.Label>Sensitivity: {detectionThreshold}</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"range\"\n          min=\"0\"\n          max=\"255\"\n          value={detectionThreshold}\n          onChange={(event) => setDetectionThreshold(event.target.value)}\n        />\n      </div>\n      <div className=\"m-2\">\n        <Button\n          variant=\"outline-primary\"\n          className=\"mx-1\"\n          onClick={(event) => recolorDetection(event)}\n        >\n          Recolor detected\n        </Button>\n        <Button\n          variant=\"outline-primary\"\n          className=\"mx-1\"\n          onClick={(event) => recolorCanvasArea(event)}\n        >\n          Color area\n        </Button>\n        <Button\n          variant=\"outline-primary\"\n          className=\"mx-1\"\n          onClick={(event) => {\n            const setNumPixelsColored = isRedEdit\n              ? setNumPixelsColoredRed\n              : setNumPixelsColoredBlue;\n            resetCanvas(\n              event,\n              canvasContext,\n              canvasWidth,\n              canvasHeight,\n              image,\n              setNumPixelsColored\n            );\n          }}\n        >\n          Reset\n        </Button>\n      </div>\n      <div>\n        <div>Red pixel count: {numPixelsColoredRed}</div>\n        <div>Blue pixel count: {numPixelsColoredBlue}</div>\n        <div>\n          Red / Blue ratio: {numPixelsColoredBlue / numPixelsColoredRed}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default ImageAnalyzer;\n","import React, { useEffect, useRef } from \"react\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const { image } = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    setCanvasContext(context);\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null) {\n      return;\n    }\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image]);\n\n  return (\n    <div>\n      <canvas ref={canvasRef} className=\"border\" />\n    </div>\n  );\n}\n\nexport default Canvas;\n","import React, { useState, useEffect } from \"react\";\nimport { Button, Card, Accordion } from \"react-bootstrap\";\nimport FileInput from \"./components/FileInput/FileInput\";\nimport ImageAnalyzer from \"./components/ImageAnalyzer/ImageAnalyzer\";\nimport Canvas from \"./components/Canvas/Canvas\";\nimport * as DomHelper from \"./utils/DomHelper\";\nimport \"./App.css\";\n\nfunction App() {\n  const [image, setImage] = useState({});\n  const [isRedEdit, setIsRedEdit] = useState(true);\n  const [canvasContextRed, setCanvasContextRed] = useState(null);\n  const [canvasContextBlue, setCanvasContextBlue] = useState(null);\n  const [canvasDimensions, setCanvasDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  useEffect(() => {\n    setCanvasDimensions({\n      width: image.width,\n      height: image.height,\n    });\n  }, image);\n\n  const saveSelectedImage = async (event) => {\n    const image = await DomHelper.getImageFromInput(event, setImage);\n    setImage(image);\n  };\n\n  const currentCanvasContext = isRedEdit\n    ? [canvasContextRed, setCanvasContextRed]\n    : [canvasContextBlue, setCanvasContextBlue];\n\n  return (\n    <div className=\"App\">\n      <h4>Welcome to G-calc</h4>\n      <div>\n        <Canvas\n          image={{\n            image: image,\n          }}\n          canvasDimensions={{\n            canvasWidth: image.width,\n            canvasHeight: image.height,\n          }}\n          drawDimensions={{\n            drawWidth: image.width,\n            drawHeight: image.height,\n          }}\n          canvasContext={[canvasContextRed, setCanvasContextRed]}\n        />\n      </div>\n      <div>\n        <Canvas\n          image={{\n            image: image,\n          }}\n          canvasDimensions={{\n            canvasWidth: image.width,\n            canvasHeight: image.height,\n          }}\n          drawDimensions={{\n            drawWidth: image.width,\n            drawHeight: image.height,\n          }}\n          canvasContext={[canvasContextBlue, setCanvasContextBlue]}\n        />\n      </div>\n      <div>\n        <Accordion defaultActiveKey=\"0\">\n          <Card>\n            <Card.Header>\n              <Accordion.Toggle as={Button} variant=\"link\" eventKey=\"0\">\n                1. Image input\n              </Accordion.Toggle>\n            </Card.Header>\n            <Accordion.Collapse eventKey=\"0\">\n              <Card.Body>\n                <FileInput\n                  accept=\"image/*\"\n                  label=\"Choose image\"\n                  onChangeHandler={saveSelectedImage}\n                />\n              </Card.Body>\n            </Accordion.Collapse>\n          </Card>\n          <Card>\n            <Card.Header>\n              <Accordion.Toggle as={Button} variant=\"link\" eventKey=\"1\">\n                2. Image analysis\n              </Accordion.Toggle>\n            </Card.Header>\n            <Accordion.Collapse eventKey=\"1\">\n              <Card.Body>\n                <ImageAnalyzer\n                  image={[image, setImage]}\n                  isRedEdit={[isRedEdit, setIsRedEdit]}\n                  canvasContext={currentCanvasContext}\n                  canvasDimensions={{\n                    canvasWidth: image.width,\n                    canvasHeight: image.height,\n                  }}\n                />\n              </Card.Body>\n            </Accordion.Collapse>\n          </Card>\n        </Accordion>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}