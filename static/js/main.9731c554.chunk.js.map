{"version":3,"sources":["assets/target/thick.png","assets/sample/400.jpeg","redux/imageReducer.js","redux/combinedCanvasInfoReducer.js","components/Canvas/Canvas.js","models/coordinate.js","models/canvasData.js","utils/ImageAnalysis.js","components/AutoReanalyze/utils.js","components/AutoReanalyze/AutoReanalyze.js","pages/Auto/index.js","components/App/index.tsx","serviceWorker.js","redux/canvasEditReducer.js","redux/innerCanvasInfoReducer.js","redux/outerCanvasInfoReducer.js","redux/canvasSettingsReducer.js","redux/videoReducer.js","redux/index.js","index.js"],"names":["module","exports","initialState","source","image","setContext","context","type","payload","setNumColoredInnerPixels","numInnerPixels","setNumColoredOuterPixels","numOuterPixels","numColoredOuterPixels","numColoredInnerPixels","Canvas","props","dispatch","useDispatch","canvasDimensions","canvasWidth","canvasHeight","drawDimensions","drawWidth","drawHeight","canvasContext","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","width","height","drawImage","className","ref","Coordinate","x","y","this","CanvasDataHelper","imageArray","redIndex","getIndex","greenIndex","blueIndex","redValue","greenValue","blueValue","alphaIndex","r","g","b","rgb","rgbPixel","alphaValue","alpha","pixelAtCoordinate","newColor","Number","coor","newR","newG","newB","tintDelta","start","end","colorSpace","require","DeltaE","getDetectedPixels","canvasData","seedCoordinate","edgeCanvas","dimensions","threshold","a","detectedPixels","push","queue","visited","Set","add","length","currentCoor","pop","getXYKey","neighbors","getNeighbors","neighborCoor","key","isWithinBoundary","has","isSimiliar","suspect","seedRgb","seedLab","lab","seedLabObj","L","A","B","suspectRgb","suspectLab","suspectLabObj","getDeltaE00","neighborsDelta","coordinate","delta","deltaX","deltaY","updateImageData","recolor","leftX","rightX","numDetectedPixels","coloredPixels","i","verticalCoordinate","tint","String","fullAnalysis","combinedCanvasInfo","detectionWidth","detectionHeight","edgeContext","getEdgeCanvasHelper","imageData","getImageData","data","findMax","maxCoor","ImageAnalysis","maxDetectedPixels","findNextMax","nextMaxCoor","nextMaxdetectedPixels","topDetectedPixels","bottomDetectedPixels","findCutOff","cuttOff","top","left","right","topPixelsCount","bottom","bottomPixelsCount","putImageData","Promise","resolve","photoOriginY","middleX","distanceFromOrigin","Math","abs","distanceFromTop","boundary","isTopToBottomSearch","intensity","MIN_SAFE_INTEGER","value","topPixels","bottomPixels","bounds","findBounds","max","min","out","MAX_SAFE_INTEGER","undefined","data_type","jsfeat","U8_t","img_u8","matrix_t","imgproc","grayscale","gaussian_blur","canny","data_u32","Uint32Array","buffer","cols","rows","pix","AnalysisResults","outerPixels","useSelector","state","imageSource","useState","setThreshold","outerNumColoredPixels","innerNumColoredPixels","webcamRef","canvasProps","combinedCanvasInfoReducer","changeThresholdBy","previous","thresholdChange","newThreshold","utils","Card","Button","variant","onClick","window","scrollTo","offsetTop","toFixed","Body","Title","e","icon","size","style","display","withOrientationChange","videoConstraints","videoReducer","canvasSettings","isPortrait","autoAnalyzeContainerRef","capture","screenshot","getScreenshot","Image","onload","src","imageReducer","autoReanalyzeProps","audio","screenshotFormat","target","AutoReanalyze","library","fab","faMinus","faPlus","faCamera","App","Boolean","location","hostname","match","isOuterEdit","recoloredImageData","numColoredPixels","recolorHex","facingMode","exact","imageSmoothing","screenshotQuality","rootReducer","combineReducers","action","canvasEdit","innerCanvasInfo","outerCanvasInfo","store","createStore","applyMiddleware","thunk","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.9731c554.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/thick.c9dcc9e1.png\";","module.exports = __webpack_public_path__ + \"static/media/400.1274d929.jpeg\";","export function setImageOnload(source) {\n  return (dispatch) => {\n    const image = new Image();\n    image.onload = () => {\n      dispatch({ type: \"IMAGE_SOURCE_SET\", payload: image });\n    };\n    image.src = source;\n  };\n}\n\nexport function setImage(image) {\n  return {\n    type: \"IMAGE_SET\",\n    payload: image,\n  };\n}\n\nconst initialState = {\n  source: null,\n  image: null,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"IMAGE_SOURCE_SET\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    case \"IMAGE_SET\":\n      return {\n        ...state,\n        image: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_COMBINE_CONTEXT\", payload: context };\n}\nexport function setNumColoredInnerPixels(numInnerPixels) {\n  return { type: \"SET_NUM_COLORED_INNER_PIXELS\", payload: numInnerPixels };\n}\nexport function setNumColoredOuterPixels(numOuterPixels) {\n  return { type: \"SET_NUM_COLORED_OUTER_PIXELS\", payload: numOuterPixels };\n}\nconst initialState = {\n  context: null,\n  numColoredOuterPixels: 0,\n  numColoredInnerPixels: 0,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_COMBINE_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_NUM_COLORED_INNER_PIXELS\":\n      return {\n        ...state,\n        numColoredInnerPixels: action.payload,\n      };\n    case \"SET_NUM_COLORED_OUTER_PIXELS\":\n      return {\n        ...state,\n        numColoredOuterPixels: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","import React, { useEffect, useRef } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const dispatch = useDispatch();\n  const image = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    dispatch(setCanvasContext(context));\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null) {\n      return;\n    }\n\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image, drawWidth, drawHeight, canvasWidth, canvasHeight]);\n\n  return (\n    <div className=\"mx-auto\">\n      <canvas ref={canvasRef} />\n    </div>\n  );\n}\n\nexport default Canvas;\n","export default class Coordinate {\n  constructor({ x, y }) {\n    this.x = x;\n    this.y = y;\n  }\n}\n","/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\nconst ALPHA_OFFSET = 3;\n\nexport default class CanvasDataHelper {\n  constructor({ canvasWidth, imageArray }) {\n    this.canvasWidth = canvasWidth;\n    this.imageArray = imageArray;\n  }\n\n  rgbPixel({ x, y }) {\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    const redValue = this.imageArray[redIndex];\n    const greenValue = this.imageArray[greenIndex];\n    const blueValue = this.imageArray[blueIndex];\n    if (redValue !== 0 && greenValue !== 0 && blueValue !== 0) {\n      const alphaIndex = getIndex(x, y, this.canvasWidth) + ALPHA_OFFSET;\n      const alphaValue = this.imageArray[alphaIndex];\n    }\n    return { r: redValue, g: greenValue, b: blueValue };\n  }\n\n  rgbaPixel({ x, y }) {\n    const rgb = this.rgbPixel({ x, y });\n    const alphaIndex = getIndex(x, y, this.canvasWidth) + ALPHA_OFFSET;\n    const alphaValue = this.imageArray[alphaIndex];\n    rgb.alpha = alphaValue;\n    return rgb;\n  }\n\n  recolor(pixelAtCoordinate, newColor) {\n    const { r, g, b } = newColor;\n    const { x, y } = pixelAtCoordinate;\n\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    this.imageArray[redIndex] = Number(r);\n    this.imageArray[greenIndex] = Number(g);\n    this.imageArray[blueIndex] = Number(b);\n  }\n\n  rRelative(coor) {\n    const { r, g, b } = this.rgbPixel(coor);\n    return b; //r * 2 - g - b;\n  }\n\n  tint(pixelAtCoordinate, newColor) {\n    const { r: newR, g: newG, b: newB } = newColor;\n\n    const { x, y } = pixelAtCoordinate;\n\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    const r = this.imageArray[redIndex];\n    const g = this.imageArray[greenIndex];\n    const b = this.imageArray[blueIndex];\n\n    this.imageArray[redIndex] += this.tintDelta(r, newR);\n    this.imageArray[greenIndex] += this.tintDelta(g, newG);\n    this.imageArray[blueIndex] += this.tintDelta(b, newB);\n  }\n\n  tintDelta(start, end) {\n    const tintFactor = 3;\n    return (end - start) / 3;\n  }\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n","import Coordinate from \"../models/coordinate\";\nimport CanvasDataHelper from \"../models/canvasData\";\nimport * as math from \"mathjs\";\n\nconst colorSpace = require(\"color-space\");\nconst DeltaE = require(\"delta-e\");\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n// Increase to relax restrictions\nconst SEED_THRESHOLD_ADJUST = 70;\nconst IS_SIMILAR_PIXEL_THRESHOLD = 100;\n\nasync function findSeed(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = 0; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\n/*\n * Laplacian\n */\n\nasync function getLaplacianArray(\n  canvasData,\n  { detectionWidth, detectionHeight }\n) {\n  const laplacianArray = [];\n\n  // Calculate requires to look one over\n  for (let y = 1; y < detectionHeight - 1; y++) {\n    const row = [];\n    for (let x = 1; x < detectionWidth - 1; x++) {\n      const coordinate = { x, y };\n      const value = await calcLaplacianValue(canvasData, coordinate);\n      row.push(value);\n    }\n\n    laplacianArray.push(row);\n  }\n\n  return laplacianArray;\n}\n\nasync function calcLaplacianValue(canvasData, coordinate) {\n  const { x, y } = coordinate;\n  const rgbPixel = canvasData.rgbPixel(coordinate);\n\n  let sum = -4 * rgbPixel.r;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    const neighbor = new Coordinate({ x: deltaX + x, y: deltaY + y });\n    const rgbPixel = canvasData.rgbPixel(neighbor);\n    sum += rgbPixel.r;\n  }\n  return sum;\n}\n\nconst red = { r: 255, g: 0, b: 0 };\nconst green = { r: 0, g: 255, b: 0 };\nconst blue = { r: 0, g: 0, b: 255 };\nasync function getDetectedPixels(\n  canvasData,\n  seedCoordinate,\n  edgeCanvas,\n  dimensions,\n  threshold\n) {\n  const { x, y } = seedCoordinate;\n  const detectedPixels = [];\n  detectedPixels.push(seedCoordinate);\n\n  let queue = [];\n  queue.push(seedCoordinate);\n  const visited = new Set();\n  visited.add(seedCoordinate);\n  while (queue.length > 0) {\n    const currentCoor = queue.pop();\n\n    const key = getXYKey(currentCoor.x, currentCoor.y);\n    const neighbors = getNeighbors(currentCoor);\n\n    for (let neighborCoor of neighbors) {\n      const key = getXYKey(neighborCoor.x, neighborCoor.y);\n\n      if (\n        isWithinBoundary(neighborCoor, dimensions) &&\n        !visited.has(key) &&\n        isSimiliar(neighborCoor, canvasData, seedCoordinate, threshold)\n      ) {\n        queue.push(neighborCoor);\n        detectedPixels.push(neighborCoor);\n      }\n      visited.add(key);\n    }\n  }\n\n  return detectedPixels;\n}\n\nfunction isSimiliar(suspect, canvasData, seedCoordinate, threshold) {\n  const seedRgb = canvasData.rgbPixel(seedCoordinate);\n  const seedLab = colorSpace.rgb.lab([seedRgb.r, seedRgb.g, seedRgb.b]);\n  const seedLabObj = { L: seedLab[0], A: seedLab[1], B: seedLab[2] };\n  const suspectRgb = canvasData.rgbPixel(suspect);\n\n  const suspectLab = colorSpace.rgb.lab([\n    suspectRgb.r,\n    suspectRgb.g,\n    suspectRgb.b,\n  ]);\n\n  const suspectLabObj = {\n    L: suspectLab[0],\n    A: suspectLab[1],\n    B: suspectLab[2],\n  };\n\n  return DeltaE.getDeltaE00(seedLabObj, suspectLabObj) < threshold;\n}\n\nfunction isWithinBoundary(coor, dimensions) {\n  const { x, y } = coor;\n  return x > 0 && x < dimensions.width && y > 0 && y < dimensions.height;\n}\n\nconst laplacianOperator = [\n  [1, 1, 1],\n  [1, -8, 1],\n  [1, 1, 1],\n];\n\nfunction findMatrixMax(matrix) {\n  let max = Number.MIN_VALUE;\n  for (let r = 0; r < matrix.length; r++) {\n    for (let c = 0; c < matrix[r].length; c++) {\n      max = Math.max(max, matrix[r][c]);\n    }\n  }\n  return max;\n}\n\nfunction isZeroCrossing(matrix) {\n  const upLeft = matrix[0][0];\n  const downRight = matrix[2][2];\n\n  const upMiddle = matrix[0][1];\n  const downMiddle = matrix[2][1];\n\n  const downLeft = matrix[2][0];\n  const upRight = matrix[0][2];\n\n  const middleLeft = matrix[1][0];\n  const middleRight = matrix[1][2];\n\n  const max = findMatrixMax(matrix);\n  return (\n    (isDifferentSign(upLeft, downRight) &&\n      isDifferentAboveThreshold(upLeft, downRight, max)) ||\n    (isDifferentSign(upMiddle, downMiddle) &&\n      isDifferentAboveThreshold(upMiddle, downMiddle, max)) ||\n    (isDifferentSign(downLeft, upRight) &&\n      isDifferentAboveThreshold(downLeft, upRight, max)) ||\n    (isDifferentSign(middleLeft, middleRight) &&\n      isDifferentAboveThreshold(middleLeft, middleRight, max))\n  );\n}\n\nfunction isDifferentSign(value1, value2) {\n  return (value1 < 0 && value2 > 0) || (value1 > 0 && value2 < 0);\n}\n\nfunction isDifferentAboveThreshold(value1, value2, max) {\n  return Math.abs(value1 - value2) > 0.3 * max;\n}\n\nfunction isEdge(coor, canvasData) {\n  const rgbPixel = canvasData.rgbPixel(coor);\n  // if all black then it is a edge pixel\n  return rgbPixel.r === 255 && rgbPixel.g === 255 && rgbPixel.b === 255;\n}\n\nconst neighborsDelta = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, -1],\n  [0, 1],\n  [1, -1],\n  [1, 0],\n  [1, 1],\n];\nfunction getNeighbors(coordinate) {\n  const neighbors = [];\n  const { x, y } = coordinate;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    neighbors.push(new Coordinate({ x: deltaX + x, y: deltaY + y }));\n  }\n\n  return neighbors;\n}\nasync function colorAreaWithBounds(\n  { width, height },\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  { leftX, rightX }\n) {\n  const imageData = combinedCanvasInfo.context.getImageData(\n    0,\n    0,\n    width,\n    height\n  );\n\n  const outerNumPixelsColored = await updateImageDataOld(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    outerCanvasInfo\n  );\n\n  const innerNumPixelsColored = await updateImageDataOld(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    innerCanvasInfo\n  );\n\n  return Promise.resolve({\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  });\n}\n\nasync function updateImageData(\n  canvasData,\n  { leftX, rightX, height },\n  recolor,\n  detectedPixels\n) {\n  let numDetectedPixels = 0;\n  const coloredPixels = new Set();\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n\n    // Go down a vertical line, stop slightly less than the middle\n    for (let i = y; i < height / 2 - 5; i++) {\n      const key = getXYKey(x, i);\n      const verticalCoordinate = { x, y: i };\n\n      // Color this pixel only if it has not been colored before and is within bounds\n      if (!coloredPixels.has(key) && leftX <= x && x <= rightX) {\n        coloredPixels.add(key);\n        //canvasData.recolor(verticalCoordinate, recolor);\n\n        canvasData.tint(verticalCoordinate, recolor);\n        numDetectedPixels++;\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\nasync function updateImageDataOld(\n  { width, height },\n  imageData,\n  { leftX, rightX },\n  canvasInfo\n) {\n  const newColor = hexToRgb(canvasInfo.recolorHex);\n\n  let {\n    numDetectedPixels,\n    existingPixels,\n  } = getBoundedPixelInfo(canvasInfo.detectedPixels, { leftX, rightX });\n\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let [, coordinate] of existingPixels) {\n    if (coordinate != null) {\n      const { x, y } = coordinate;\n\n      for (let i = y; i < height / 2; i++) {\n        if (!isExistingPixel(x, i)) {\n          const redIndex = getIndex(x, i, width) + R_OFFSET;\n          const greenIndex = getIndex(x, i, width) + G_OFFSET;\n          const blueIndex = getIndex(x, i, width) + B_OFFSET;\n          imageData.data[redIndex] = newColor.r;\n          imageData.data[greenIndex] = newColor.g;\n          imageData.data[blueIndex] = newColor.b;\n\n          const currentKey = getXYKey(x, i);\n          existingPixels.set(currentKey, null);\n          numDetectedPixels++;\n        }\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\nfunction getBoundedPixelInfo(detectedPixels, { leftX, rightX }) {\n  const existingPixels = new Map();\n\n  let numDetectedPixels = 0;\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    if (x >= leftX && x <= rightX) {\n      const key = getXYKey(x, y);\n      existingPixels.set(key, coordinate);\n      numDetectedPixels++;\n    }\n  }\n\n  return {\n    numDetectedPixels,\n    existingPixels,\n  };\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} hex\n */\nfunction hexToRgb(hex) {\n  let red = 0,\n    green = 0,\n    blue = 0;\n  if (hex.length == 4) {\n    red = \"0x\" + hex[1] + hex[1];\n    green = \"0x\" + hex[2] + hex[2];\n    blue = \"0x\" + hex[3] + hex[3];\n  } else if (hex.length == 7) {\n    red = \"0x\" + hex[1] + hex[2];\n    green = \"0x\" + hex[3] + hex[4];\n    blue = \"0x\" + hex[5] + hex[6];\n  }\n  return { r: red, g: green, b: blue };\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\nexport { colorAreaWithBounds, getDetectedPixels, updateImageData, isEdge };\n","import * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport CanvasDataHelper from \"../../models/canvasData\";\nimport jsfeat from \"jsfeat\";\n\n// Consider that some non chart area will be capture, thus start the calculations from a padding, not from the very top\nconst START_HEIGHT = 30;\n\n// If the y coor is greater? \nconst WITHIN_HEIGHT = 185;\n\nasync function fullAnalysis(image, combinedCanvasInfo, canvasRef, threshold) {\n  const { width, height } = image;\n  const dimensions = {\n    detectionWidth: width,\n    detectionHeight: height,\n  };\n\n  // Edge canvas stuff\n  const { current: canvas } = canvasRef;\n  const edgeContext = canvas.getContext(\"2d\");\n  const edgeCanvas = await getEdgeCanvasHelper(image, edgeContext);\n\n  /*\n   * Setup\n   */\n\n  const { context } = combinedCanvasInfo;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: dimensions.detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  /*\n   * Extremas\n   */\n\n  // Global extrema we look for the most \"X\" of a pixel, for ex. red\n  const maxCoor = await findMax(canvasData, dimensions);\n  const maxDetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    maxCoor,\n    edgeCanvas,\n    { width, height },\n    threshold\n  );\n\n  // Now we look for the next \"X\" of a pixel that is some distance away from the one before\n  const nextMaxCoor = await findNextMax(maxCoor, canvasData, width, height);\n\n  const nextMaxdetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    nextMaxCoor,\n    edgeCanvas,\n    { width, height },\n    threshold\n  );\n\n  /*\n   * Assign top / bottom\n   */\n\n  // assume that max coor is above next max\n  let topDetectedPixels = maxDetectedPixels;\n  let bottomDetectedPixels = nextMaxdetectedPixels;\n\n  // Means that max coor is not above next max\n  if (maxCoor.y > nextMaxCoor.y) {\n    // Switch them\n    [topDetectedPixels, bottomDetectedPixels] = [\n      bottomDetectedPixels,\n      topDetectedPixels,\n    ];\n  }\n\n  /*\n   * Recolor\n   */\n\n  //  Cutoff finding\n  const cuttOff = await findCutOff(\n    topDetectedPixels,\n    bottomDetectedPixels\n  );\n\n  // Recoloring\n  const recolor = { r: 0, g: 255, b: 0 };\n  const topPixelsCount = await ImageAnalysis.updateImageData(\n    canvasData,\n    { leftX: cuttOff.top.left.x , rightX: cuttOff.top.right.x , height },\n    recolor,\n    topDetectedPixels\n  );\n\n  const bottomPixelsCount = await ImageAnalysis.updateImageData(\n    canvasData,\n    { leftX: cuttOff.bottom.left.x , rightX: cuttOff.bottom.right.x, height },\n    { r: 0, g: 0, b: 255 },\n    bottomDetectedPixels\n  );\n\n  context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    dimensions.detectionWidth,\n    dimensions.detectionHeight\n  );\n\n  return Promise.resolve({ topPixelsCount, bottomPixelsCount });\n}\n\nasync function findNextMax(maxCoor, canvasData, width, height) {\n  // Setup\n  const photoOriginY = height / 2;\n  const middleX = width / 2;\n\n  const distanceFromOrigin = Math.abs(maxCoor.y - photoOriginY);\n  const distanceFromTop = maxCoor.y;\n\n  // If the already found coor's distance from the bottom (origin) is less than the tops then\n  // it's closer to the bottom and we are searching from top to bottom\n  const isTopToBottomSearch = distanceFromOrigin < distanceFromTop;\n  let boundary = distanceFromTop;\n\n  // Ensure that boundary is least some distance from the top / bottom so it won't be mistaken\n  boundary += isTopToBottomSearch ? -10 : 10;\n\n  let coor = { x: middleX };\n  let intensity = Number.MIN_SAFE_INTEGER;\n\n  let y = isTopToBottomSearch ? START_HEIGHT : photoOriginY;\n\n  while (y !== boundary) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n\n    if (value > intensity) {\n      coor = { y: y, x: middleX };\n      intensity = value;\n    }\n    isTopToBottomSearch ? y++ : y--;\n  }\n  return coor;\n}\n\nasync function findMax(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = START_HEIGHT; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\nfunction calculatedLossPercent(outerPixels, innerPixels) {\n  let percentage = (100 * (outerPixels - innerPixels)) / outerPixels;\n  return percentage.toFixed(2);\n}\n\n/**\n * We consider something \"within\" if the end\n *\n *\n * Divide the chart up into 4 quadrants. Let quadrant I be the top right and quadrant II be the top left.\n * The logic for I and II are the same but just applied to one side\n *\n * There are 6 possible scenarios\n * 1. Both top and bottom ends are \"Within\"\n * 2. Top is not within and bottom is, top horizontally extends beyond the bottom end (Top longer)\n *\n *   Top longer | Top within | Bottom within\n * 3. yes         yes           no\n * 4. no          no            yes\n * 5. yes         no            no\n * 6. no          no            no\n * Case 3-6 we just \"double bound\" the cutoff see function\n *\n * @param {*} topPixels\n * @param {*} bottomPixels\n */\nasync function findCutOff(topPixels, bottomPixels) {\n\n  const bounds = findBounds(topPixels, bottomPixels);\n  \n  /*\n   * Leftside\n   */\n  \n   // both are NOT within \n  if( !(bounds.top.left.y > WITHIN_HEIGHT && bounds.bottom.left.y > WITHIN_HEIGHT) &&\n\n      // bottom is within and the top is more left\n    !(bounds.bottom.left.y > WITHIN_HEIGHT && bounds.top.left.x < bounds.bottom.left.x) ){\n\n      // Cap the cutoff to the more limiting of the x on the left side\n      const left = Math.max(bounds.top.left.x, bounds.bottom.left.x);\n      bounds.top.left.x = left;\n      bounds.bottom.left.x = left;\n  }\n\n  /*\n   * Rightside\n   */\n\n      // both are NOT within \n  if( !(bounds.top.right.y > WITHIN_HEIGHT && bounds.bottom.right.y > WITHIN_HEIGHT) &&\n\n      // bottom is within and the top is more left\n    !(bounds.bottom.right.y > WITHIN_HEIGHT && bounds.top.right.x > bounds.bottom.right.x) ){\n      const right = Math.min(bounds.top.right.x, bounds.bottom.right.x);\n      bounds.top.right.x = right;\n      bounds.bottom.right.x = right;\n  }\n  return bounds;\n}\n\n/**\n * Find the left and right most\n * @param {*} topPixels\n * @param {*} bottomPixels\n */\nfunction findBounds(topPixels, bottomPixels) {\n\n  const out = {\n    top: {\n      left: {\n        x: Number.MAX_SAFE_INTEGER,\n        y: undefined,\n      },\n      right: {\n        x: 0,\n        y: undefined,\n      },\n    },\n    bottom: {\n      left: {\n        x: Number.MAX_SAFE_INTEGER,\n        y: undefined,\n      },\n      right: {\n        x: 0,\n        y: undefined,\n      },\n    }\n  };\n\n  for (let coordinate of topPixels) {\n    const { x, y } = coordinate;\n    if( x < out.top.left.x ){\n      out.top.left.x = x;\n      out.top.left.y = y;\n    }\n    if( x > out.top.right.x ){\n      out.top.right.x = x;\n      out.top.right.y = y;\n    }\n  }\n\n  for (let coordinate of bottomPixels) {\n    const { x, y } = coordinate;    \n    if( x < out.bottom.left.x ){\n      out.bottom.left.x = x;\n      out.bottom.left.y = y;\n    }\n    if( x > out.bottom.right.x ){\n      out.bottom.right.x = x;\n      out.bottom.right.y = y;\n    }\n  }\n\n  return out;\n}\n\n/* Not in use  */\nasync function getEdgeCanvasHelper(image, context) {\n  const { width, height } = image;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const columns = 450,\n    rows = 320,\n    data_type = jsfeat.U8_t;\n  let img_u8 = new jsfeat.matrix_t(columns, rows, data_type);\n  jsfeat.imgproc.grayscale(imageData.data, width, height, img_u8);\n\n  let r = 3; // 0 -4\n  let kernel_size = (r + 1) << 1;\n  let low_threshold = 120; // 1 - 127\n  let high_threshold = 120; // 1 - 127\n\n  jsfeat.imgproc.gaussian_blur(img_u8, img_u8, kernel_size, 0);\n\n  jsfeat.imgproc.canny(img_u8, img_u8, low_threshold, high_threshold);\n\n  // render result back to canvas\n  var data_u32 = new Uint32Array(imageData.data.buffer);\n  var alpha = 0xff << 24;\n  var i = img_u8.cols * img_u8.rows,\n    pix = 0;\n  while (--i >= 0) {\n    pix = img_u8.data[i];\n    data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;\n  }\n\n  // Draw canny\n  context.putImageData(imageData, 0, 0, 0, 0, width, height);\n\n  const edgeCanvas = new CanvasDataHelper({\n    canvasWidth: width,\n    imageArray: imageData.data,\n  });\n\n  return edgeCanvas;\n}\n\nasync function colorEdges(image, combinedCanvasInfo) {\n  const { width, height } = image;\n  const dimensions = {\n    detectionWidth: width,\n    detectionHeight: height,\n  };\n\n  const { context } = combinedCanvasInfo;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: dimensions.detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  for (let y = 5; y < height / 2; y++) {\n    for (let x = 5; x < width - 10; x++) {\n      const coor = { x, y };\n      if (ImageAnalysis.isEdge(coor, canvasData)) {\n        canvasData.recolor(coor, { r: 0, g: 255, b: 0 });\n      }\n    }\n  }\n\n  context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    dimensions.detectionWidth,\n    dimensions.detectionHeight\n  );\n}\n\nexport {\n  calculatedLossPercent,\n  fullAnalysis,\n  colorEdges,\n  getEdgeCanvasHelper,\n}; \n","import React, { useState, useRef, useEffect } from \"react\";\nimport { Button, Card } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\nimport * as DomHelper from \"../../utils/DomHelper\";\n\nfunction AnalysisResults(props) {\n  const dispatch = useDispatch();\n\n  // State\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n  const imageSource = useSelector((state) => state.image.source);\n  const [threshold, setThreshold] = useState(20);\n\n  const outerNumColoredPixels = combinedCanvasInfo.numColoredOuterPixels;\n  const innerNumColoredPixels = combinedCanvasInfo.numColoredInnerPixels;\n\n  // Props\n  const { webcamRef } = props;\n\n  // Child props\n  const canvasProps = {\n    ...props,\n    canvasContext: [\n      combinedCanvasInfo.context,\n      combinedCanvasInfoReducer.setContext,\n    ],\n  };\n\n  const canvasRef = useRef(null);\n\n  function changeThresholdBy(value) {\n    setThreshold((previous) => Math.max(0, previous + value));\n  }\n\n  useEffect(() => {\n    if (imageSource) {\n      fullAnalysis(0);\n    }\n  }, [imageSource]);\n\n  async function fullAnalysis(thresholdChange) {\n    const newThreshold = threshold + thresholdChange;\n    const { topPixelsCount, bottomPixelsCount } = await utils.fullAnalysis(\n      imageSource,\n      combinedCanvasInfo,\n      canvasRef,\n      newThreshold\n    );\n    dispatch(\n      combinedCanvasInfoReducer.setNumColoredOuterPixels(topPixelsCount)\n    );\n    dispatch(\n      combinedCanvasInfoReducer.setNumColoredInnerPixels(bottomPixelsCount)\n    );\n    changeThresholdBy(thresholdChange);\n  }\n\n  return (\n    <Card>\n      {imageSource && <h2 className=\"card-title\">Results</h2>}\n      <div>\n        <Canvas {...canvasProps} />\n        {imageSource && (\n          <div\n            className={`d-flex justify-content-around align-items-center mb-4`}\n          >\n            <div>\n              <Button\n                variant=\"outline-primary\"\n                onClick={() => {\n                  window.scrollTo(0, webcamRef.current.offsetTop);\n                }}\n              >\n                Retake picture\n              </Button>\n\n              <div>\n                <h3 className=\"mt-4\">\n                  Loss:{\" \"}\n                  {utils.calculatedLossPercent(\n                    outerNumColoredPixels,\n                    innerNumColoredPixels\n                  )}\n                  %\n                </h3>\n              </div>\n            </div>\n\n            <Card>\n              <Card.Body>\n                <Card.Title>Sensitivity: {threshold}</Card.Title>\n                <div className=\"container\">\n                  <div className=\"row justify-content-around mb-3\">\n                    <Button\n                      onClick={(e) => {\n                        fullAnalysis(-2);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"minus\" size=\"1x\" />\n                    </Button>\n                    <Button\n                      onClick={(e) => {\n                        fullAnalysis(2);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"plus\" size=\"1x\" />\n                    </Button>\n                  </div>\n                  <div className=\"row justify-content-between\">\n                    <Button\n                      onClick={(e) => {\n                        fullAnalysis(-5);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"minus\" size=\"1x\" />\n                      {\"  \"}\n                      <FontAwesomeIcon icon=\"minus\" size=\"1x\" />\n                    </Button>\n                    <Button\n                      onClick={(e) => {\n                        fullAnalysis(5);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"plus\" size=\"1x\" />\n                      {\"  \"}\n                      <FontAwesomeIcon icon=\"plus\" size=\"1x\" />\n                    </Button>\n                  </div>\n                </div>\n              </Card.Body>\n            </Card>\n          </div>\n        )}\n      </div>\n\n      {/* Used for edge canvas */}\n      <canvas style={{ display: \"none\" }} ref={canvasRef} />\n    </Card>\n  );\n}\n\nexport default AnalysisResults;\n","import React, { useRef, useEffect } from \"react\";\nimport { Button, Card } from \"react-bootstrap\";\nimport { withOrientationChange } from \"react-device-detect\";\nimport Webcam from \"react-webcam\";\nimport * as imageReducer from \"../../redux/imageReducer\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport AutoReanalyze from \"../../components/AutoReanalyze/AutoReanalyze\";\nimport target from \"../../assets/target/thick.png\";\nimport \"./index.css\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport sampleChart from \"../../assets/sample/400.jpeg\";\n\nfunction Auto(props) {\n  // Setup\n  const dispatch = useDispatch();\n\n  // Redux\n  const videoConstraints = useSelector(\n    (state) => state.videoReducer.videoConstraints\n  );\n  const image = useSelector((state) => state.image.source);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  // Props\n  const { isPortrait } = props;\n\n  // Ref\n  const webcamRef = useRef(null);\n  const autoAnalyzeContainerRef = useRef(null);\n\n  // UseEffect - Remove this later, just for testing\n  useEffect(() => {\n    //dispatch(imageReducer.setImageOnload(sampleChart));\n  }, []);\n\n  const capture = () => {\n    const screenshot = webcamRef.current.getScreenshot();\n    dispatch(imageReducer.setImageOnload(screenshot));\n    dispatch(imageReducer.setImage(screenshot));\n    window.scrollTo(0, autoAnalyzeContainerRef.current.offsetTop);\n  };\n\n  // Children props setup\n  const autoReanalyzeProps = {\n    webcamRef,\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n    isPortrait,\n  };\n\n  return (\n    <div className=\"App\">\n      <Card className=\"mt-4\">\n        <h2 className=\"card-title\">Capture chart</h2>\n        <div className=\"mx-auto\">\n          <div className=\"capture-container mx-auto\">\n            <Webcam\n              audio={false}\n              height={videoConstraints.height}\n              ref={webcamRef}\n              screenshotFormat=\"image/jpeg\"\n              width={videoConstraints.width}\n              videoConstraints={videoConstraints}\n            />\n            <div className=\"overlay\">\n              <img\n                className=\"target\"\n\n                //width -20 leaves some padding on the left and right side\n                style={{ width: videoConstraints.width - 20 }}\n                src={target}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"my-2 z-top mx-auto\">\n          <Button className=\"capture-button\" onClick={() => capture()}>\n            <FontAwesomeIcon icon=\"camera\" size=\"3x\" />\n          </Button>\n        </div>\n      </Card>\n      <div className=\"mt-4\" ref={autoAnalyzeContainerRef}>\n        <AutoReanalyze {...autoReanalyzeProps} />\n      </div>\n      <br />\n      <br />\n      <br />\n    </div>\n  );\n}\n\nexport default withOrientationChange(Auto);\n","import React from \"react\";\nimport AutoReanalyze from \"../../pages/Auto/index\";\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport { fab } from \"@fortawesome/free-brands-svg-icons\";\nimport { faMinus, faPlus, faCamera } from \"@fortawesome/free-solid-svg-icons\";\n\nlibrary.add(fab, faMinus, faPlus, faCamera);\nfunction App() {\n  return (\n    <>\n      <AutoReanalyze />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export function toggleIsOuterEdit() {\n  return { type: \"TOGGLE_IS_OUTER_EDIT\" };\n}\n\nconst initialState = {\n  isOuterEdit: true,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"TOGGLE_IS_OUTER_EDIT\":\n      return {\n        ...state,\n        isOuterEdit: !state.isOuterEdit,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_INNER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_INNER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_INNER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_INNER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_INNER_RECOLOR_HEX\", payload: hex };\n}\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#00FF00\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_INNER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_INNER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_INNER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_INNER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_INNER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_OUTER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_OUTER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_OUTER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_OUTER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_OUTER_RECOLOR_HEX\", payload: hex };\n}\n\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#FFA500\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_OUTER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_OUTER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_OUTER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_OUTER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_OUTER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setCanvasDimensions(dimensions) {\n  return { type: \"SET_CANVAS_DIMENSIONS\", payload: dimensions };\n}\n\nconst initialState = {\n  canvasDimensions: {\n    width: 400,\n    height: 400,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_CANVAS_DIMENSIONS\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","const initialState = {\n  videoConstraints: {\n\n    // These numbers should match those in the canvas settings\n    width: 400,\n    height: 400,\n    facingMode: { exact: \"environment\" },\n    //facingMode: \"user\",\n    audio: false,\n    imageSmoothing: true,\n    screenshotQuality: 1,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    default:\n      return state;\n  }\n}\n","import { combineReducers, createStore, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport imageReducer from \"./imageReducer\";\nimport canvasEditReducer from \"./canvasEditReducer\";\nimport innerCanvasInfoReducer from \"./innerCanvasInfoReducer\";\nimport outerCanvasInfoReducer from \"./outerCanvasInfoReducer\";\nimport combinedCanvasInfoReducer from \"./combinedCanvasInfoReducer\";\nimport canvasSettingsReducer from \"./canvasSettingsReducer\";\nimport videoReducer from \"./videoReducer\";\n\nconst rootReducer = combineReducers({\n  image: imageReducer,\n  canvasEdit: canvasEditReducer,\n  innerCanvasInfo: innerCanvasInfoReducer,\n  outerCanvasInfo: outerCanvasInfoReducer,\n  combinedCanvasInfo: combinedCanvasInfoReducer,\n  canvasSettings: canvasSettingsReducer,\n  videoReducer: videoReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App/index\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Provider } from \"react-redux\";\nimport store from \"./redux\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}