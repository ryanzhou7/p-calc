{"version":3,"sources":["assets/target/thick.png","assets/top-max.jpeg","redux/imageReducer.js","redux/combinedCanvasInfoReducer.js","components/Canvas/Canvas.js","models/coordinate.js","models/canvasData.js","utils/ImageAnalysis.js","components/AutoReanalyze/utils.js","components/AutoReanalyze/AutoReanalyze.js","pages/Auto/index.js","pages/Home/index.js","components/App/index.tsx","serviceWorker.js","redux/canvasEditReducer.js","redux/innerCanvasInfoReducer.js","redux/outerCanvasInfoReducer.js","redux/canvasSettingsReducer.js","redux/videoReducer.js","redux/index.js","index.js"],"names":["module","exports","initialState","source","setContext","context","type","payload","setNumColoredInnerPixels","numInnerPixels","setNumColoredOuterPixels","numOuterPixels","numColoredOuterPixels","numColoredInnerPixels","Canvas","props","dispatch","useDispatch","image","canvasDimensions","canvasWidth","canvasHeight","drawDimensions","drawWidth","drawHeight","canvasContext","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","width","height","drawImage","ref","className","Coordinate","x","y","this","CanvasDataHelper","imageArray","redIndex","getIndex","greenIndex","blueIndex","r","g","b","pixelAtCoordinate","newColor","Number","getDetectedPixels","canvasData","seedCoordinate","a","detectedPixels","push","queue","visited","Set","length","currentCoor","pop","key","getXYKey","add","neighbors","getNeighbors","neighborCoor","has","isSimiliar","origin","suspect","seedRgb","rgbPixel","seedThreshold","originRgb","suspectRgb","Math","abs","neighborsDelta","coordinate","delta","deltaX","deltaY","updateImageData","recolor","leftX","rightX","numDetectedPixels","coloredPixels","i","verticalCoordinate","String","fullAnalysis","combinedCanvasInfo","dimensions","detectionWidth","detectionHeight","imageData","getImageData","data","findMax","maxCoor","ImageAnalysis","maxDetectedPixels","findNextMax","nextMaxCoor","nextMaxdetectedPixels","topDetectedPixels","bottomDetectedPixels","findCutOff","left","right","topPixelsCount","bottomPixelsCount","putImageData","Promise","resolve","photoOriginY","middleX","distanceFromOrigin","distanceFromTop","boundary","isTopToBottomSearch","MIN_VALUE","MAX_VALUE","boundaryComparator","max","min","coor","intensity","value","detectedPixels1","detectedPixels2","smallestX1","smallestX2","largestX1","largestX2","AnalysisResults","outerPixels","useSelector","state","outerCanvasInfo","innerCanvasInfo","imageSource","canvasSettings","outerNumColoredPixels","innerNumColoredPixels","webcamRef","canvasProps","combinedCanvasInfoReducer","utils","top","bottom","Button","variant","onClick","window","scrollTo","offsetTop","toFixed","withOrientationChange","videoConstraints","videoReducer","isPortrait","captureContainerRef","autoAnalyzeContainerRef","capture","useCallback","screenshot","getScreenshot","Image","onload","src","autoReanalyzeProps","style","position","float","audio","screenshotFormat","target","AutoReanalyze","Home","App","Boolean","location","hostname","match","isOuterEdit","recoloredImageData","numColoredPixels","recolorHex","facingMode","exact","imageSmoothing","screenshotQuality","rootReducer","combineReducers","action","canvasEdit","store","createStore","applyMiddleware","thunk","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.58da7b3e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/thick.c9dcc9e1.png\";","module.exports = __webpack_public_path__ + \"static/media/top-max.9741321e.jpeg\";","export function setImage(source) {\n  return (dispatch) => {\n    const image = new Image();\n    image.onload = () => {\n      dispatch({ type: \"IMAGE_SET\", payload: image });\n    };\n    image.src = source;\n  };\n}\n\nexport function setImageCallback(dispatch) {\n  return (image) => {\n    dispatch({\n      type: \"IMAGE_SET\",\n      payload: image,\n    });\n  };\n}\n\nconst initialState = {\n  source: null,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"IMAGE_SET\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_COMBINE_CONTEXT\", payload: context };\n}\nexport function setNumColoredInnerPixels(numInnerPixels) {\n  return { type: \"SET_NUM_COLORED_INNER_PIXELS\", payload: numInnerPixels };\n}\nexport function setNumColoredOuterPixels(numOuterPixels) {\n  return { type: \"SET_NUM_COLORED_OUTER_PIXELS\", payload: numOuterPixels };\n}\nconst initialState = {\n  context: null,\n  numColoredOuterPixels: 0,\n  numColoredInnerPixels: 0,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_COMBINE_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_NUM_COLORED_INNER_PIXELS\":\n      return {\n        ...state,\n        numColoredInnerPixels: action.payload,\n      };\n    case \"SET_NUM_COLORED_OUTER_PIXELS\":\n      return {\n        ...state,\n        numColoredOuterPixels: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","import React, { useEffect, useRef } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const dispatch = useDispatch();\n  const image = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    dispatch(setCanvasContext(context));\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null) {\n      return;\n    }\n\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image, drawWidth, drawHeight, canvasWidth, canvasHeight]);\n\n  return (\n    <div>\n      <canvas ref={canvasRef} className=\"border\" />\n    </div>\n  );\n}\n\nexport default Canvas;\n","export default class Coordinate {\n  constructor({ x, y }) {\n    this.x = x;\n    this.y = y;\n  }\n}\n","/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\nexport default class CanvasDataHelper {\n  constructor({ canvasWidth, imageArray }) {\n    this.canvasWidth = canvasWidth;\n    this.imageArray = imageArray;\n  }\n\n  rgbPixel({ x, y }) {\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    const redValue = this.imageArray[redIndex];\n    const greenValue = this.imageArray[greenIndex];\n    const blueValue = this.imageArray[blueIndex];\n    return { r: redValue, g: greenValue, b: blueValue };\n  }\n\n  recolor(pixelAtCoordinate, newColor) {\n    const { r, g, b } = newColor;\n    const { x, y } = pixelAtCoordinate;\n\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    this.imageArray[redIndex] = Number(r);\n    this.imageArray[greenIndex] = Number(g);\n    this.imageArray[blueIndex] = Number(b);\n  }\n\n  tint(pixelAtCoordinate, newColor) {}\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n","import Coordinate from \"../models/coordinate\";\nimport CanvasDataHelper from \"../models/canvasData\";\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n// Increase to relax restrictions\nconst SEED_THRESHOLD_ADJUST = 40;\nconst IS_SIMILAR_PIXEL_THRESHOLD = 40;\n\nasync function detectGrow(canvasContext, detectionDimensions, recolorHex) {\n  const { detectionWidth, detectionHeight } = detectionDimensions;\n  const imageData = canvasContext.getImageData(\n    0,\n    0,\n    detectionWidth,\n    detectionHeight\n  );\n\n  const newColor = hexToRgb(recolorHex);\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  const seedCoordinate = await findSeed(canvasData, detectionDimensions);\n  const detectedPixels = await getDetectedPixels(canvasData, seedCoordinate);\n\n  for (let coor of detectedPixels) {\n    canvasData.recolor(coor, newColor);\n  }\n\n  return Promise.resolve([imageData, detectedPixels]);\n}\n\nasync function findSeed(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = 0; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\n/*\n * Laplacian\n */\n\nasync function getLaplacianArray(\n  canvasData,\n  { detectionWidth, detectionHeight }\n) {\n  const laplacianArray = [];\n\n  // Calculate requires to look one over\n  for (let y = 1; y < detectionHeight - 1; y++) {\n    const row = [];\n    for (let x = 1; x < detectionWidth - 1; x++) {\n      const coordinate = { x, y };\n      const value = await calcLaplacianValue(canvasData, coordinate);\n      row.push(value);\n    }\n\n    laplacianArray.push(row);\n  }\n\n  return laplacianArray;\n}\n\nasync function calcLaplacianValue(canvasData, coordinate) {\n  const { x, y } = coordinate;\n  const rgbPixel = canvasData.rgbPixel(coordinate);\n\n  let sum = -4 * rgbPixel.r;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    const neighbor = new Coordinate({ x: deltaX + x, y: deltaY + y });\n    const rgbPixel = canvasData.rgbPixel(neighbor);\n    sum += rgbPixel.r;\n  }\n  return sum;\n}\n\nasync function getDetectedPixels(canvasData, seedCoordinate) {\n  const { x, y } = seedCoordinate;\n  const detectedPixels = [];\n  detectedPixels.push(seedCoordinate);\n\n  let queue = [];\n  queue.push(seedCoordinate);\n  const visited = new Set();\n\n  while (queue.length > 0) {\n    const currentCoor = queue.pop();\n\n    const key = getXYKey(currentCoor.x, currentCoor.y);\n    visited.add(key);\n    const neighbors = getNeighbors(currentCoor);\n\n    for (let neighborCoor of neighbors) {\n      const key = getXYKey(neighborCoor.x, neighborCoor.y);\n      if (\n        !visited.has(key) &&\n        isSimiliar(currentCoor, neighborCoor, canvasData, seedCoordinate)\n      ) {\n        queue.push(neighborCoor);\n        detectedPixels.push(neighborCoor);\n        visited.add(key);\n      }\n    }\n  }\n\n  return detectedPixels;\n}\n\nfunction isSimiliar(origin, suspect, canvasData, seedCoordinate) {\n  const seedRgb = canvasData.rgbPixel(seedCoordinate);\n  const seedThreshold = seedRgb.r * 2 - seedRgb.g - seedRgb.b;\n\n  const originRgb = canvasData.rgbPixel(origin);\n  const suspectRgb = canvasData.rgbPixel(suspect);\n\n  return (\n    // check if this is \"red\"\n    suspectRgb.r * 2 - suspectRgb.g - suspectRgb.b + SEED_THRESHOLD_ADJUST >\n      seedThreshold &&\n    // check if each of these values are not too different from the origin\n    Math.abs(originRgb.r - suspectRgb.r) < IS_SIMILAR_PIXEL_THRESHOLD &&\n    Math.abs(originRgb.g - suspectRgb.g) < IS_SIMILAR_PIXEL_THRESHOLD &&\n    Math.abs(originRgb.b - suspectRgb.b) < IS_SIMILAR_PIXEL_THRESHOLD\n  );\n}\n\nconst neighborsDelta = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, -1],\n  [0, 1],\n  [1, -1],\n  [1, 0],\n  [1, 1],\n];\nfunction getNeighbors(coordinate) {\n  const neighbors = [];\n  const { x, y } = coordinate;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    neighbors.push(new Coordinate({ x: deltaX + x, y: deltaY + y }));\n  }\n\n  return neighbors;\n}\nasync function colorAreaWithBounds(\n  { width, height },\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  { leftX, rightX }\n) {\n  const imageData = combinedCanvasInfo.context.getImageData(\n    0,\n    0,\n    width,\n    height\n  );\n\n  const outerNumPixelsColored = await updateImageDataOld(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    outerCanvasInfo\n  );\n\n  const innerNumPixelsColored = await updateImageDataOld(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    innerCanvasInfo\n  );\n\n  return Promise.resolve({\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  });\n}\n\nasync function updateImageData(\n  canvasData,\n  { leftX, rightX, height },\n  recolor,\n  detectedPixels\n) {\n  let numDetectedPixels = 0;\n  const coloredPixels = new Set();\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n\n    // Go down a vertical line\n    for (let i = y; i < height / 2; i++) {\n      const key = getXYKey(x, i);\n      const verticalCoordinate = { x, y: i };\n\n      // Color this pixel only if it has not been colored before and is within bounds\n      if (!coloredPixels.has(key) && leftX <= x && x <= rightX) {\n        coloredPixels.add(key);\n        canvasData.recolor(verticalCoordinate, recolor);\n        numDetectedPixels++;\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\nasync function updateImageDataOld(\n  { width, height },\n  imageData,\n  { leftX, rightX },\n  canvasInfo\n) {\n  const newColor = hexToRgb(canvasInfo.recolorHex);\n\n  let {\n    numDetectedPixels,\n    existingPixels,\n  } = getBoundedPixelInfo(canvasInfo.detectedPixels, { leftX, rightX });\n\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let [, coordinate] of existingPixels) {\n    if (coordinate != null) {\n      const { x, y } = coordinate;\n\n      for (let i = y; i < height / 2; i++) {\n        if (!isExistingPixel(x, i)) {\n          const redIndex = getIndex(x, i, width) + R_OFFSET;\n          const greenIndex = getIndex(x, i, width) + G_OFFSET;\n          const blueIndex = getIndex(x, i, width) + B_OFFSET;\n          imageData.data[redIndex] = newColor.r;\n          imageData.data[greenIndex] = newColor.g;\n          imageData.data[blueIndex] = newColor.b;\n\n          const currentKey = getXYKey(x, i);\n          existingPixels.set(currentKey, null);\n          numDetectedPixels++;\n        }\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\nfunction getBoundedPixelInfo(detectedPixels, { leftX, rightX }) {\n  const existingPixels = new Map();\n\n  let numDetectedPixels = 0;\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    if (x >= leftX && x <= rightX) {\n      const key = getXYKey(x, y);\n      existingPixels.set(key, coordinate);\n      numDetectedPixels++;\n    }\n  }\n\n  return {\n    numDetectedPixels,\n    existingPixels,\n  };\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} hex\n */\nfunction hexToRgb(hex) {\n  let red = 0,\n    green = 0,\n    blue = 0;\n  if (hex.length == 4) {\n    red = \"0x\" + hex[1] + hex[1];\n    green = \"0x\" + hex[2] + hex[2];\n    blue = \"0x\" + hex[3] + hex[3];\n  } else if (hex.length == 7) {\n    red = \"0x\" + hex[1] + hex[2];\n    green = \"0x\" + hex[3] + hex[4];\n    blue = \"0x\" + hex[5] + hex[6];\n  }\n  return { r: red, g: green, b: blue };\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\nexport { detectGrow, colorAreaWithBounds, getDetectedPixels, updateImageData };\n","import * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport CanvasDataHelper from \"../../models/canvasData\";\n\nasync function fullAnalysis(image, combinedCanvasInfo) {\n  const { width, height } = image;\n  const dimensions = {\n    detectionWidth: width,\n    detectionHeight: height,\n  };\n\n  /*\n   * Setup\n   */\n\n  const { context } = combinedCanvasInfo;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: dimensions.detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  /*\n   * Max / Next Max\n   */\n\n  // Max\n  const maxCoor = await findMax(canvasData, dimensions);\n  const maxDetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    maxCoor\n  );\n\n  // Next max\n  const nextMaxCoor = await findNextMax(\n    maxCoor,\n    maxDetectedPixels,\n    canvasData,\n    width,\n    height\n  );\n  const nextMaxdetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    nextMaxCoor\n  );\n\n  /*\n   * Max / Next Max -> top / bottom\n   */\n\n  // assume that max coor is above next max\n  let topDetectedPixels = maxDetectedPixels;\n  let bottomDetectedPixels = nextMaxdetectedPixels;\n\n  // Means that max coor is not above next max\n  if (maxCoor.y > nextMaxCoor.y) {\n    // Switch them\n    [topDetectedPixels, bottomDetectedPixels] = [\n      bottomDetectedPixels,\n      topDetectedPixels,\n    ];\n  }\n\n  /*\n   * Recolor\n   */\n\n  //  Cutoff finding\n  const { left: leftX, right: rightX } = await findCutOff(\n    topDetectedPixels,\n    bottomDetectedPixels\n  );\n\n  // Recoloring\n  const recolor = { r: 0, g: 255, b: 0 };\n  const topPixelsCount = await ImageAnalysis.updateImageData(\n    canvasData,\n    { leftX, rightX, height },\n    recolor,\n    topDetectedPixels\n  );\n\n  const bottomPixelsCount = await ImageAnalysis.updateImageData(\n    canvasData,\n    { leftX, rightX, height },\n    { r: 0, g: 255, b: 255 },\n    bottomDetectedPixels\n  );\n\n  context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    dimensions.detectionWidth,\n    dimensions.detectionHeight\n  );\n\n  return Promise.resolve({ topPixelsCount, bottomPixelsCount, context });\n}\n\nasync function findNextMax(maxCoor, detectedPixels, canvasData, width, height) {\n  // Setup\n  const photoOriginY = height / 2;\n  const middleX = width / 2;\n\n  const distanceFromOrigin = Math.abs(maxCoor.y - photoOriginY);\n  const distanceFromTop = maxCoor.y;\n\n  // If the already found coor's distance from the bottom (origin) is less than the tops then\n  // it's closer to the bottom and we are searching from top to bottom\n  const isTopToBottomSearch = distanceFromOrigin < distanceFromTop;\n\n  // If we are search from top to bottom it means the current max is the bottom\n  // Hence, from the detected bottom line when need to find the biggest y as the boundary\n  let boundary = isTopToBottomSearch ? Number.MIN_VALUE : Number.MAX_VALUE;\n  const boundaryComparator = isTopToBottomSearch ? Math.max : Math.min;\n\n  for (let { y } of detectedPixels) {\n    boundary = boundaryComparator(boundary, y);\n  }\n\n  // Ensure that boundary is least some distance from the top / bottom\n  boundary += isTopToBottomSearch ? -5 : 5;\n\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  let y = isTopToBottomSearch ? 0 : photoOriginY;\n\n  while (y !== boundary) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n    isTopToBottomSearch ? y++ : y--;\n  }\n  return coor;\n}\n\nasync function findMax(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = 0; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\nfunction calculatedLossPercent(outerPixels, innerPixels) {\n  let percentage = (100 * (outerPixels - innerPixels)) / outerPixels;\n  return percentage.toFixed(4);\n}\n\nasync function combinedAnalysis(\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  canvasDimensions,\n  dispatch\n) {\n  const outerDetectedPixels = outerCanvasInfo.detectedPixels;\n  const innerDetectedPixels = innerCanvasInfo.detectedPixels;\n  const { left: leftX, right: rightX } = await findCutOff(\n    outerDetectedPixels,\n    innerDetectedPixels\n  );\n\n  const {\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  } = await ImageAnalysis.colorAreaWithBounds(\n    canvasDimensions,\n    outerCanvasInfo,\n    innerCanvasInfo,\n    combinedCanvasInfo,\n    { leftX, rightX }\n  );\n\n  combinedCanvasInfo.context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    canvasDimensions.width,\n    canvasDimensions.height\n  );\n  dispatch(combinedCanvasInfoReducer.setContext(combinedCanvasInfo.context));\n\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredInnerPixels(innerNumPixelsColored)\n  );\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredOuterPixels(outerNumPixelsColored)\n  );\n}\n\nasync function findCutOff(detectedPixels1, detectedPixels2) {\n  let smallestX1 = Number.MAX_VALUE;\n  let smallestX2 = Number.MAX_VALUE;\n\n  let largestX1 = 0;\n  let largestX2 = 0;\n\n  for (let coordinate of detectedPixels1) {\n    const { x } = coordinate;\n    smallestX1 = Math.min(smallestX1, x);\n    largestX1 = Math.max(largestX1, x);\n  }\n\n  for (let coordinate of detectedPixels2) {\n    const { x } = coordinate;\n    smallestX2 = Math.min(smallestX2, x);\n    largestX2 = Math.max(largestX2, x);\n  }\n\n  return {\n    left: Math.max(smallestX1, smallestX2),\n    right: Math.min(largestX1, largestX2),\n  };\n}\n\nexport { calculatedLossPercent, combinedAnalysis, fullAnalysis };\n","import React from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\n\nfunction AnalysisResults(props) {\n  const dispatch = useDispatch();\n\n  // State\n  const outerCanvasInfo = useSelector((state) => state.outerCanvasInfo);\n  const innerCanvasInfo = useSelector((state) => state.innerCanvasInfo);\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n  const imageSource = useSelector((state) => state.image.source);\n\n  const outerNumColoredPixels = combinedCanvasInfo.numColoredOuterPixels;\n  const innerNumColoredPixels = combinedCanvasInfo.numColoredInnerPixels;\n\n  // Props\n  const { webcamRef } = props;\n\n  // Child props\n  const canvasProps = {\n    ...props,\n    canvasContext: [\n      combinedCanvasInfo.context,\n      combinedCanvasInfoReducer.setContext,\n    ],\n  };\n\n  async function fullAnalysis() {\n    const {\n      topPixelsCount: top,\n      bottomPixelsCount: bottom,\n      context,\n    } = await utils.fullAnalysis(imageSource, combinedCanvasInfo);\n\n    // don't have to do this to update ?\n    dispatch(combinedCanvasInfoReducer.setContext(context));\n    dispatch(combinedCanvasInfoReducer.setNumColoredOuterPixels(top));\n    dispatch(combinedCanvasInfoReducer.setNumColoredInnerPixels(bottom));\n  }\n\n  return (\n    <div>\n      <div className=\"d-flex justify-content-around align-items-center\">\n        <Canvas {...canvasProps} />\n\n        <div>\n          <Button\n            className=\"my-1\"\n            variant=\"outline-primary\"\n            onClick={() => {\n              window.scrollTo(0, webcamRef.current.offsetTop);\n            }}\n          >\n            Retake\n          </Button>\n\n          <div>\n            <div className=\"my-4\">\n              <Button className=\"mr-4\" variant=\"outline-primary\">\n                -\n              </Button>\n              <Button variant=\"outline-primary\">+</Button>\n            </div>\n            <Button onClick={fullAnalysis}>Analyze</Button>\n          </div>\n          <div className=\"mt-4\">\n            Loss:{\" \"}\n            {utils.calculatedLossPercent(\n              outerNumColoredPixels,\n              innerNumColoredPixels\n            )}\n            %\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default AnalysisResults;\n","import React, { useRef, useCallback, useEffect } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { withOrientationChange } from \"react-device-detect\";\nimport Webcam from \"react-webcam\";\nimport * as imageReducer from \"../../redux/imageReducer\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport AutoReanalyze from \"../../components/AutoReanalyze/AutoReanalyze\";\nimport target from \"../../assets/target/thick.png\";\nimport \"./index.css\";\nimport * as DomHelper from \"../../utils/DomHelper\";\nimport sampleChart from \"../../assets/top-max.jpeg\";\n//import sampleChart from \"../../assets/image-5.jpeg\";\n\nfunction Auto(props) {\n  // Setup\n  const dispatch = useDispatch();\n\n  // Redux\n  const videoConstraints = useSelector(\n    (state) => state.videoReducer.videoConstraints\n  );\n  const image = useSelector((state) => state.image.source);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  // Props\n  const { isPortrait } = props;\n\n  // Ref\n  const webcamRef = useRef(null);\n  const captureContainerRef = useRef(null);\n  const autoAnalyzeContainerRef = useRef(null);\n\n  // UseEffect - Remove this later, just for testing\n  useEffect(() => {\n    //dispatch(imageReducer.setImage(sampleChart));\n  }, []);\n\n  // Other hooks\n  const capture = useCallback(() => {\n    const screenshot = webcamRef.current.getScreenshot();\n    dispatch(imageReducer.setImage(screenshot));\n    window.scrollTo(0, autoAnalyzeContainerRef.current.offsetTop);\n  }, [webcamRef]);\n\n  // Children props setup\n  const autoReanalyzeProps = {\n    webcamRef,\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n  };\n\n  return (\n    <div className=\"App\">\n      <h2>Ptosis calculator</h2>\n      {isPortrait && <h5>Please rotate your device</h5>}\n\n      {!isPortrait && (\n        <div\n          className=\"d-flex justify-content-around align-items-center\"\n          ref={captureContainerRef}\n        >\n          <div style={{ position: \"relative\", float: \"top\" }}>\n            <Webcam\n              audio={false}\n              height={videoConstraints.height}\n              ref={webcamRef}\n              screenshotFormat=\"image/jpeg\"\n              width={videoConstraints.width}\n              videoConstraints={videoConstraints}\n            />\n            <div className=\"overlay\">\n              <img\n                className=\"target\"\n                style={{ height: videoConstraints.height }}\n                src={target}\n              />\n            </div>\n          </div>\n          <div className=\"my-3\">\n            <Button onClick={() => capture()}>Take picture</Button>\n          </div>\n        </div>\n      )}\n      <div ref={autoAnalyzeContainerRef}>\n        <AutoReanalyze {...autoReanalyzeProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default withOrientationChange(Auto);\n","import React from \"react\";\nimport Auto from \"../Auto\";\nfunction Home() {\n  return (\n    <>\n      <Auto />\n    </>\n  );\n}\n\nexport default Home;\n","import React from \"react\";\nimport Home from \"../../pages/Home\";\n\nfunction App() {\n  return (\n    <>\n      <Home />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export function toggleIsOuterEdit() {\n  return { type: \"TOGGLE_IS_OUTER_EDIT\" };\n}\n\nconst initialState = {\n  isOuterEdit: true,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"TOGGLE_IS_OUTER_EDIT\":\n      return {\n        ...state,\n        isOuterEdit: !state.isOuterEdit,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_INNER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_INNER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_INNER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_INNER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_INNER_RECOLOR_HEX\", payload: hex };\n}\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#00FF00\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_INNER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_INNER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_INNER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_INNER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_INNER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_OUTER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_OUTER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_OUTER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_OUTER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_OUTER_RECOLOR_HEX\", payload: hex };\n}\n\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#FFA500\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_OUTER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_OUTER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_OUTER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_OUTER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_OUTER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setCanvasDimensions(dimensions) {\n  return { type: \"SET_CANVAS_DIMENSIONS\", payload: dimensions };\n}\n\nconst initialState = {\n  canvasDimensions: {\n    width: 450,\n    height: 320,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_CANVAS_DIMENSIONS\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","const initialState = {\n  videoConstraints: {\n    width: 450,\n    height: 320,\n    facingMode: { exact: \"environment\" },\n    //facingMode: \"user\",\n    audio: false,\n    imageSmoothing: true,\n    screenshotQuality: 1,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    default:\n      return state;\n  }\n}\n","import { combineReducers, createStore, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport imageReducer from \"./imageReducer\";\nimport canvasEditReducer from \"./canvasEditReducer\";\nimport innerCanvasInfoReducer from \"./innerCanvasInfoReducer\";\nimport outerCanvasInfoReducer from \"./outerCanvasInfoReducer\";\nimport combinedCanvasInfoReducer from \"./combinedCanvasInfoReducer\";\nimport canvasSettingsReducer from \"./canvasSettingsReducer\";\nimport videoReducer from \"./videoReducer\";\n\nconst rootReducer = combineReducers({\n  image: imageReducer,\n  canvasEdit: canvasEditReducer,\n  innerCanvasInfo: innerCanvasInfoReducer,\n  outerCanvasInfo: outerCanvasInfoReducer,\n  combinedCanvasInfo: combinedCanvasInfoReducer,\n  canvasSettings: canvasSettingsReducer,\n  videoReducer: videoReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App/index\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Provider } from \"react-redux\";\nimport store from \"./redux\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}