{"version":3,"sources":["components/FileInput/FileInput.js","utils/DomHelper.js","utils/ImageAnalysis.js","utils/Canvas.js","components/ImageAnalyzer/ImageAnalyzer.js","components/Canvas/Canvas.js","App.js","serviceWorker.js","index.js"],"names":["inputStyle","width","FileInput","props","label","accept","onChangeHandler","Form","File","type","style","custom","onChange","e","getImageFromInput","event","a","Promise","resolve","reject","target","files","item","imageSource","URL","createObjectURL","image","Image","onload","src","isRed","threshold","r","g","b","detect","detectionDimensions","imageData","isColor","recolorHex","detectionWidth","detectionHeight","hexToRgb","redRecolor","greenRecolor","blueRecolor","detectedPixels","originalPixels","data","slice","y","x","redIndex","getIndex","greenIndex","blueIndex","redValue","greenValue","blueValue","Number","push","colorArea","canvasContext","newColorHex","height","getImageData","numPixelsColored","maxY","existingPixels","Map","isExistingPixel","containsXYKeyIn","getXYKey","coordinate","Math","max","key","set","i","String","getKey","map","has","h","length","setWithImage","context","drawImage","ImageAnalyzer","canvasDimensions","canvasWidth","canvasHeight","useState","detectionThreshold","setDetectionThreshold","setNumPixelsColored","setDetectedPixels","setRecolorHex","isColorDetector","ImageAnalysis","recoloredImageData","putImageData","numPixels","preventDefault","Canvas","Label","Control","className","value","min","Button","onClick","recolorDetection","recolorCanvasArea","reset","drawDimensions","drawWidth","drawHeight","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","ref","App","setImage","setCanvasDimensions","useLayoutEffect","saveSelectedImage","DomHelper","Accordion","defaultActiveKey","Card","Header","Toggle","as","variant","eventKey","Collapse","Body","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.19bd07bc.chunk.js","sourcesContent":["import React from \"react\";\nimport { Form } from \"react-bootstrap\";\n\nfunction FileInput(props) {\n  const { label } = props;\n  const { accept } = props;\n  const { onChangeHandler } = props;\n  return (\n    <div>\n      <Form.File\n        type=\"file\"\n        accept={accept}\n        label={label}\n        style={inputStyle}\n        custom\n        onChange={(e) => onChangeHandler(e)}\n      />\n    </div>\n  );\n}\n\nconst inputStyle = {\n  width: \"300px\",\n};\n\nexport default FileInput;\n","/**\n * Return the image with it's source loaded from an file input\n * @param {*} event\n */\nasync function getImageFromInput(event) {\n  return new Promise((resolve, reject) => {\n    if (event.target.files && event.target.files.item(0)) {\n      const imageSource = URL.createObjectURL(event.target.files[0]);\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.src = imageSource;\n      return;\n    }\n    reject(\"No file selected\");\n  });\n}\n\nfunction setFromInput(event, setter) {\n  const { value } = event.target;\n  setter(value);\n}\n\nexport { getImageFromInput, setFromInput };\n","/**\n * Basic algorithm for red detection\n * @param {*} threshold\n */\nfunction isRed(threshold) {\n  return (r, g, b) => r * 2 - (g + b) > threshold;\n}\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n/**\n * Detects the color, recolors it, and return the newly recolored image / number of pixels colored\n * @param {*} detectionDimensions\n * @param {*} imageData\n * @param {*} isColor\n * @param {*} recolorHex\n */\nasync function detect(detectionDimensions, imageData, isColor, recolorHex) {\n  const { detectionWidth, detectionHeight } = detectionDimensions;\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(recolorHex);\n  const detectedPixels = [];\n\n  const originalPixels = imageData.data.slice();\n\n  for (let y = 0; y < detectionHeight; y++) {\n    for (let x = 0; x < detectionWidth; x++) {\n      const redIndex = getIndex(x, y, detectionWidth) + R_OFFSET;\n      const greenIndex = getIndex(x, y, detectionWidth) + G_OFFSET;\n      const blueIndex = getIndex(x, y, detectionWidth) + B_OFFSET;\n\n      const redValue = originalPixels[redIndex];\n      const greenValue = originalPixels[greenIndex];\n      const blueValue = originalPixels[blueIndex];\n\n      if (isColor(redValue, greenValue, blueValue)) {\n        imageData.data[redIndex] = Number(redRecolor);\n        imageData.data[greenIndex] = Number(greenRecolor);\n        imageData.data[blueIndex] = Number(blueRecolor);\n        detectedPixels.push({ x: x, y: y });\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, detectedPixels]);\n}\n\n/**\n * Color the canvas area and return how many detected pixels there are\n * @param {*} param0\n * @param {*} canvasContext\n * @param {*} newColorHex\n * @param {*} detectedPixels\n */\nasync function colorArea(\n  { width, height },\n  canvasContext,\n  newColorHex,\n  detectedPixels\n) {\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(newColorHex);\n  const imageData = canvasContext.getImageData(0, 0, width, height);\n  let numPixelsColored = 0;\n  let maxY = 0;\n\n  const existingPixels = new Map();\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    maxY = Math.max(y, maxY);\n    const key = getXYKey(x, y);\n    existingPixels.set(key, null);\n    numPixelsColored++;\n  }\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    for (let i = y; i < maxY; i++) {\n      if (!isExistingPixel(x, i)) {\n        const redIndex = getIndex(x, i, width) + R_OFFSET;\n        const greenIndex = getIndex(x, i, width) + G_OFFSET;\n        const blueIndex = getIndex(x, i, width) + B_OFFSET;\n        imageData.data[redIndex] = redRecolor;\n        imageData.data[greenIndex] = greenRecolor;\n        imageData.data[blueIndex] = blueRecolor;\n        numPixelsColored++;\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, numPixelsColored]);\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} h\n */\nfunction hexToRgb(h) {\n  let r = 0,\n    g = 0,\n    b = 0;\n  if (h.length == 4) {\n    r = \"0x\" + h[1] + h[1];\n    g = \"0x\" + h[2] + h[2];\n    b = \"0x\" + h[3] + h[3];\n  } else if (h.length == 7) {\n    r = \"0x\" + h[1] + h[2];\n    g = \"0x\" + h[3] + h[4];\n    b = \"0x\" + h[5] + h[6];\n  }\n  return [r, g, b];\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n\nexport { detect, colorArea, isRed };\n","// TODO to be implemented / fixed!\n\nconst WIDTH_PADDING = 50;\n\nasync function drawRotated(context, canvas, degrees, image) {\n  if (canvas == null || image == null || context == null) {\n    return;\n  }\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.save();\n  context.translate(canvas.width / 2, canvas.height / 2);\n  context.rotate(degreesToRadians(degrees));\n\n  const width = window.innerWidth - WIDTH_PADDING;\n  const height = (image.height / width) * width;\n  context.drawImage(image, -width / 2, -height / 2);\n  context.restore();\n}\n\nfunction drawAxis(context, canvas, axisCoordinates, image) {\n  if (canvas == null || image == null) {\n    return;\n  }\n  const { x: xOffset, y: yOffset } = axisCoordinates;\n  const { width: canvasWidth, height: canvasHeight } = canvas;\n  const originX = 0;\n  const originY = canvasHeight / 2 + yOffset;\n  context.beginPath();\n  context.moveTo(originX, originY + yOffset);\n  context.lineTo(originX + canvasWidth, originY + yOffset);\n  context.strokeStyle = \"#FF0000\";\n  context.stroke();\n}\n\nfunction degreesToRadians(degrees) {\n  return degrees * 0.01745;\n}\n\nfunction clearCanvasDrawing(context, width, height) {\n  if (context == null) {\n    return;\n  }\n  context.clearRect(0, 0, width, height);\n}\n\nfunction setWithImage(context, width, height, image) {\n  if (context == null) {\n    return;\n  }\n  context.drawImage(image, 0, 0, width, height);\n}\n\nexport { drawRotated, drawAxis, clearCanvasDrawing, setWithImage };\n","import React, { useState } from \"react\";\nimport { Button, Form } from \"react-bootstrap\";\nimport * as DomHelper from \"../../utils/DomHelper\";\nimport * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as Canvas from \"../../utils/Canvas\";\nimport \"./index.css\";\n\nfunction ImageAnalyzer(props) {\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const [image] = props.image;\n  const [detectionThreshold, setDetectionThreshold] = useState(150);\n  const [numPixelsColored, setNumPixelsColored] = useState(0);\n  const [canvasContext] = props.canvasContext;\n  const [detectedPixels, setDetectedPixels] = useState([]);\n  const [recolorHex, setRecolorHex] = useState(\"#0000FF\");\n\n  async function recolorDetection() {\n    const { width: detectionWidth, height: detectionHeight } = image;\n    const detectionDimensions = { detectionWidth, detectionHeight };\n    const imageData = canvasContext.getImageData(\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n\n    const isColorDetector = ImageAnalysis.isRed(detectionThreshold);\n\n    const [recoloredImageData, detectedPixels] = await ImageAnalysis.detect(\n      detectionDimensions,\n      imageData,\n      isColorDetector,\n      recolorHex\n    );\n\n    canvasContext.putImageData(\n      recoloredImageData,\n      0,\n      0,\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n    setDetectedPixels(detectedPixels);\n  }\n\n  async function recolorCanvasArea() {\n    const [imageData, numPixels] = await ImageAnalysis.colorArea(\n      image,\n      canvasContext,\n      recolorHex,\n      detectedPixels\n    );\n    setNumPixelsColored(numPixels);\n    canvasContext.putImageData(\n      imageData,\n      0,\n      0,\n      0,\n      0,\n      canvasWidth,\n      canvasHeight\n    );\n  }\n\n  async function reset(event) {\n    event.preventDefault();\n    Canvas.setWithImage(canvasContext, canvasWidth, canvasHeight, image);\n    setNumPixelsColored(0);\n  }\n\n  return (\n    <div>\n      <div>\n        <Form.Label>Recolor:</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"color\"\n          value={recolorHex}\n          onChange={(e) => DomHelper.setFromInput(e, setRecolorHex)}\n        />\n      </div>\n      <div>\n        <Form.Label>Sensitivity: {detectionThreshold}</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"range\"\n          min=\"0\"\n          max=\"255\"\n          value={detectionThreshold}\n          onChange={(e) => setDetectionThreshold(e.target.value)}\n        />\n      </div>\n      <div className=\"m-2\">\n        <Button className=\"mx-1\" onClick={(e) => recolorDetection(e)}>\n          Recolor detected\n        </Button>\n        <Button className=\"mx-1\" onClick={(e) => recolorCanvasArea(e)}>\n          Color area\n        </Button>\n        <Button className=\"mx-1\" onClick={(event) => reset(event)}>\n          Reset\n        </Button>\n      </div>\n      <div>\n        <div>Pixel count: {numPixelsColored}</div>\n      </div>\n    </div>\n  );\n}\n\nexport default ImageAnalyzer;\n","import React, { useEffect, useRef } from \"react\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const { image } = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    setCanvasContext(context);\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null) {\n      return;\n    }\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image]);\n\n  return (\n    <div>\n      <canvas ref={canvasRef} className=\"border\" />\n    </div>\n  );\n}\n\nexport default Canvas;\n","import React, { useState, useLayoutEffect } from \"react\";\nimport { Button, Card, Accordion } from \"react-bootstrap\";\nimport FileInput from \"./components/FileInput/FileInput\";\nimport ImageAnalyzer from \"./components/ImageAnalyzer/ImageAnalyzer\";\nimport Canvas from \"./components/Canvas/Canvas\";\nimport * as DomHelper from \"./utils/DomHelper\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./App.css\";\n\nfunction App() {\n  const [image, setImage] = useState({});\n  const [canvasContext, setCanvasContext] = useState(null);\n  const [canvasDimensions, setCanvasDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  useLayoutEffect(() => {\n    setCanvasDimensions({\n      width: image.width,\n      height: image.height,\n    });\n  }, image);\n\n  const saveSelectedImage = async (e) => {\n    const image = await DomHelper.getImageFromInput(e, setImage);\n    setImage(image);\n  };\n\n  return (\n    <div className=\"App\">\n      <h4>Welcome to G-calc</h4>\n      <div>\n        <Canvas\n          image={{\n            image: image,\n          }}\n          canvasDimensions={{\n            canvasWidth: image.width,\n            canvasHeight: image.height,\n          }}\n          drawDimensions={{\n            drawWidth: image.width,\n            drawHeight: image.height,\n          }}\n          canvasContext={[canvasContext, setCanvasContext]}\n        />\n      </div>\n      <div>\n        <Accordion defaultActiveKey=\"0\">\n          <Card>\n            <Card.Header>\n              <Accordion.Toggle as={Button} variant=\"link\" eventKey=\"0\">\n                1. Image input\n              </Accordion.Toggle>\n            </Card.Header>\n            <Accordion.Collapse eventKey=\"0\">\n              <Card.Body>\n                <FileInput\n                  accept=\"image/*\"\n                  label=\"Choose image\"\n                  onChangeHandler={saveSelectedImage}\n                />\n              </Card.Body>\n            </Accordion.Collapse>\n          </Card>\n          <Card>\n            <Card.Header>\n              <Accordion.Toggle as={Button} variant=\"link\" eventKey=\"1\">\n                2. Image analysis\n              </Accordion.Toggle>\n            </Card.Header>\n            <Accordion.Collapse eventKey=\"1\">\n              <Card.Body>\n                <ImageAnalyzer\n                  image={[image, setImage]}\n                  canvasContext={[canvasContext, setCanvasContext]}\n                  canvasDimensions={{\n                    canvasWidth: image.width,\n                    canvasHeight: image.height,\n                  }}\n                />\n              </Card.Body>\n            </Accordion.Collapse>\n          </Card>\n        </Accordion>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}