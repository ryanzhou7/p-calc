{"version":3,"sources":["assets/target/thick.png","assets/black-red.jpeg","redux/innerCanvasInfoReducer.js","redux/outerCanvasInfoReducer.js","redux/canvasEditReducer.js","components/ColorToggler/ColorToggler.js","models/coordinate.js","models/canvasData.js","utils/ImageAnalysis.js","utils/Canvas.js","components/CanvasEffectButtonGroup/utils.js","components/CanvasEffectButtonGroup/CanvasEffectButtonGroup.js","components/ImageAnalyzer/ImageAnalyzer.js","components/Canvas/Canvas.js","redux/imageReducer.js","redux/combinedCanvasInfoReducer.js","components/AnalysisResults/utils.js","components/AnalysisResults/AnalysisResults.js","pages/Manual/index.js","pages/Manual/utils.js","components/AutoReanalyze/utils.js","components/AutoReanalyze/AutoReanalyze.js","pages/Auto/index.js","pages/Home/index.js","components/App/index.tsx","serviceWorker.js","redux/canvasSettingsReducer.js","redux/videoReducer.js","redux/index.js","index.js"],"names":["module","exports","setContext","context","type","payload","setDetectedPixels","detectedPixels","setRecolorHex","hex","initialState","recoloredImageData","numColoredPixels","recolorHex","isOuterEdit","ColorToggler","useSelector","state","canvasEdit","dispatch","useDispatch","canvasEditToggler","Button","active","className","variant","onClick","Coordinate","x","y","this","CanvasDataHelper","canvasWidth","imageArray","redIndex","getIndex","greenIndex","blueIndex","r","g","b","pixelAtCoordinate","newColor","Number","width","detectGrow","canvasContext","detectionDimensions","a","detectionWidth","detectionHeight","imageData","getImageData","hexToRgb","canvasData","data","findSeed","seedCoordinate","getDetectedPixels","coor","recolor","Promise","resolve","middleX","intensity","coordinate","rgbPixel","value","push","queue","visited","Set","length","currentCoor","pop","key","getXYKey","add","neighbors","getNeighbors","neighborCoor","has","isSimiliar","e","console","error","origin","suspect","seedRgb","seedThreshold","originRgb","suspectRgb","Math","abs","neighborsDelta","delta","deltaX","deltaY","colorAreaWithBounds","outerCanvasInfo","innerCanvasInfo","combinedCanvasInfo","height","leftX","rightX","updateImageData","outerNumPixelsColored","innerNumPixelsColored","canvasInfo","getBoundedPixelInfo","numDetectedPixels","existingPixels","isExistingPixel","containsXYKeyIn","i","currentKey","set","Map","String","getKey","map","red","green","blue","setWithImage","image","drawImage","event","canvasHeight","setNumPixelsColored","preventDefault","Canvas","recolorDetection","ImageAnalysis","putImageData","CanvasEffectButtonGroup","props","source","canvasSettings","canvasDimensions","currentCanvasInfo","canvasContextInput","utils","outerCanvasInfoReducer","innerCanvasInfoReducer","setNumColoredPixels","ImageAnalyzer","useState","detectionThreshold","setDetectionThreshold","changeDetectionThresholdBy","previous","newValue","parseInt","innerRecolorHex","outerRecolorHex","canvasColorOptionsProps","Form","Label","Control","onChange","target","min","max","drawDimensions","drawWidth","drawHeight","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","ref","setImage","Image","onload","src","setNumColoredInnerPixels","numInnerPixels","setNumColoredOuterPixels","numOuterPixels","numColoredOuterPixels","numColoredInnerPixels","combinedAnalysis","outerDetectedPixels","innerDetectedPixels","findLeftCutOff","findRightCutOff","combinedCanvasInfoReducer","smallestOuter","MAX_SAFE_INTEGER","smallestInner","largestOuter","largestInner","AnalysisResults","outerPixels","imageSource","outerNumColoredPixels","innerNumColoredPixels","canvasProps","toFixed","withOrientationChange","videoConstraints","videoReducer","innerCanvasContext","outerCanvasContext","imageReducer","sampleChart","isPortrait","webcamRef","captureContainerRef","capture","useCallback","screenshot","getScreenshot","fileName","document","createElement","href","download","click","downloadJpegInClient","outerCanvasProps","setOuterContext","innerCanvasProps","setInnerContext","analysisResultsProps","style","position","float","audio","screenshotFormat","fullAnalysis","dimensions","findMax","maxCoor","maxDetectedPixels","findNextMax","nextMaxCoor","nextMaxdetectedPixels","allDetectedPixels","photoOriginY","distanceFromOrigin","distanceFromTop","boundary","isTopToBottomSearch","MAX_VALUE","MIN_VALUE","boundaryComparator","autoReanalyzeProps","AutoReanalyze","Home","to","activeClassName","path","App","Boolean","window","location","hostname","match","facingMode","exact","imageSmoothing","screenshotQuality","rootReducer","combineReducers","action","store","createStore","applyMiddleware","thunk","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.69a58b88.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/thick.c9dcc9e1.png\";","module.exports = __webpack_public_path__ + \"static/media/black-red.048e3ad1.jpeg\";","export function setContext(context) {\n  return { type: \"SET_INNER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_INNER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_INNER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_INNER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_INNER_RECOLOR_HEX\", payload: hex };\n}\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#00FF00\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_INNER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_INNER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_INNER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_INNER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_INNER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_OUTER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_OUTER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_OUTER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_OUTER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_OUTER_RECOLOR_HEX\", payload: hex };\n}\n\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#FFA500\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_OUTER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_OUTER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_OUTER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_OUTER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_OUTER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function toggleIsOuterEdit() {\n  return { type: \"TOGGLE_IS_OUTER_EDIT\" };\n}\n\nconst initialState = {\n  isOuterEdit: true,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"TOGGLE_IS_OUTER_EDIT\":\n      return {\n        ...state,\n        isOuterEdit: !state.isOuterEdit,\n      };\n    default:\n      return state;\n  }\n}\n","import { Button } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as canvasEditReducer from \"../../redux/canvasEditReducer\";\nimport React from \"react\";\nfunction ColorToggler() {\n  const isOuterEdit = useSelector((state) => state.canvasEdit.isOuterEdit);\n  const dispatch = useDispatch();\n  const canvasEditToggler = () => {\n    dispatch(canvasEditReducer.toggleIsOuterEdit());\n  };\n  return (\n    <div>\n      <div>Currently editing:</div>\n      <Button\n        active={isOuterEdit}\n        className=\"mr-2\"\n        variant=\"outline-danger\"\n        onClick={canvasEditToggler}\n      >\n        Outer\n      </Button>\n      <Button\n        active={!isOuterEdit}\n        variant=\"outline-primary\"\n        onClick={canvasEditToggler}\n      >\n        Inner\n      </Button>\n    </div>\n  );\n}\n\nexport default ColorToggler;\n","export default class Coordinate {\n  constructor({ x, y }) {\n    this.x = x;\n    this.y = y;\n  }\n}\n","/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\nexport default class CanvasDataHelper {\n  constructor({ canvasWidth, imageArray }) {\n    this.canvasWidth = canvasWidth;\n    this.imageArray = imageArray;\n  }\n\n  rgbPixel({ x, y }) {\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    const redValue = this.imageArray[redIndex];\n    const greenValue = this.imageArray[greenIndex];\n    const blueValue = this.imageArray[blueIndex];\n    return { r: redValue, g: greenValue, b: blueValue };\n  }\n\n  recolor(pixelAtCoordinate, newColor) {\n    const { r, g, b } = newColor;\n    const { x, y } = pixelAtCoordinate;\n\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    this.imageArray[redIndex] = Number(r);\n    this.imageArray[greenIndex] = Number(g);\n    this.imageArray[blueIndex] = Number(b);\n  }\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n","import Coordinate from \"../models/coordinate\";\nimport CanvasDataHelper from \"../models/canvasData\";\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n// Increase to relax restrictions\nconst SEED_THRESHOLD_ADJUST = 50;\nconst IS_SIMILAR_PIXEL_THRESHOLD = 50;\n\nasync function detectGrow(canvasContext, detectionDimensions, recolorHex) {\n  const { detectionWidth, detectionHeight } = detectionDimensions;\n  const imageData = canvasContext.getImageData(\n    0,\n    0,\n    detectionWidth,\n    detectionHeight\n  );\n\n  const newColor = hexToRgb(recolorHex);\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  const seedCoordinate = await findSeed(canvasData, detectionDimensions);\n  const detectedPixels = await getDetectedPixels(canvasData, seedCoordinate);\n\n  for (let coor of detectedPixels) {\n    canvasData.recolor(coor, newColor);\n  }\n\n  return Promise.resolve([imageData, detectedPixels]);\n}\n\nasync function findSeed(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = 0; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\n/*\n * Laplacian\n */\n\nasync function getLaplacianArray(\n  canvasData,\n  { detectionWidth, detectionHeight }\n) {\n  const laplacianArray = [];\n\n  // Calculate requires to look one over\n  for (let y = 1; y < detectionHeight - 1; y++) {\n    const row = [];\n    for (let x = 1; x < detectionWidth - 1; x++) {\n      const coordinate = { x, y };\n      const value = await calcLaplacianValue(canvasData, coordinate);\n      row.push(value);\n    }\n\n    laplacianArray.push(row);\n  }\n\n  return laplacianArray;\n}\n\nasync function calcLaplacianValue(canvasData, coordinate) {\n  const { x, y } = coordinate;\n  const rgbPixel = canvasData.rgbPixel(coordinate);\n\n  let sum = -4 * rgbPixel.r;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    const neighbor = new Coordinate({ x: deltaX + x, y: deltaY + y });\n    const rgbPixel = canvasData.rgbPixel(neighbor);\n    sum += rgbPixel.r;\n  }\n  return sum;\n}\n\nasync function getDetectedPixels(canvasData, seedCoordinate) {\n  const { x, y } = seedCoordinate;\n  const detectedPixels = [];\n  detectedPixels.push(seedCoordinate);\n\n  let queue = [];\n  queue.push(seedCoordinate);\n  const visited = new Set();\n\n  while (queue.length > 0) {\n    const currentCoor = queue.pop();\n\n    try {\n      const key = getXYKey(currentCoor.x, currentCoor.y);\n      visited.add(key);\n      const neighbors = getNeighbors(currentCoor);\n\n      for (let neighborCoor of neighbors) {\n        const key = getXYKey(neighborCoor.x, neighborCoor.y);\n        if (\n          !visited.has(key) &&\n          isSimiliar(currentCoor, neighborCoor, canvasData, seedCoordinate)\n        ) {\n          queue.push(neighborCoor);\n          detectedPixels.push(neighborCoor);\n          visited.add(key);\n        }\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  return detectedPixels;\n}\n\nfunction isSimiliar(origin, suspect, canvasData, seedCoordinate) {\n  const seedRgb = canvasData.rgbPixel(seedCoordinate);\n  const seedThreshold = seedRgb.r * 2 - seedRgb.g - seedRgb.b;\n\n  const originRgb = canvasData.rgbPixel(origin);\n  const suspectRgb = canvasData.rgbPixel(suspect);\n\n  return (\n    // check if this is \"red\"\n    suspectRgb.r * 2 - suspectRgb.g - suspectRgb.b + SEED_THRESHOLD_ADJUST >\n      seedThreshold &&\n    // check if each of these values are not too different from the origin\n    Math.abs(originRgb.r - suspectRgb.r) < IS_SIMILAR_PIXEL_THRESHOLD &&\n    Math.abs(originRgb.g - suspectRgb.g) < IS_SIMILAR_PIXEL_THRESHOLD &&\n    Math.abs(originRgb.b - suspectRgb.b) < IS_SIMILAR_PIXEL_THRESHOLD\n  );\n}\n\nconst neighborsDelta = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, -1],\n  [0, 1],\n  [1, -1],\n  [1, 0],\n  [1, 1],\n];\nfunction getNeighbors(coordinate) {\n  const neighbors = [];\n  const { x, y } = coordinate;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    neighbors.push(new Coordinate({ x: deltaX + x, y: deltaY + y }));\n  }\n\n  return neighbors;\n}\nasync function colorAreaWithBounds(\n  { width, height },\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  { leftX, rightX }\n) {\n  const imageData = combinedCanvasInfo.context.getImageData(\n    0,\n    0,\n    width,\n    height\n  );\n\n  const outerNumPixelsColored = await updateImageData(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    outerCanvasInfo\n  );\n\n  const innerNumPixelsColored = await updateImageData(\n    { width, height },\n    imageData,\n    { leftX, rightX },\n    innerCanvasInfo\n  );\n\n  return Promise.resolve({\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  });\n}\n\nasync function updateImageData(\n  { width, height },\n  imageData,\n  { leftX, rightX },\n  canvasInfo\n) {\n  const newColor = hexToRgb(canvasInfo.recolorHex);\n\n  let {\n    numDetectedPixels,\n    existingPixels,\n  } = getBoundedPixelInfo(canvasInfo.detectedPixels, { leftX, rightX });\n\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let [, coordinate] of existingPixels) {\n    if (coordinate != null) {\n      const { x, y } = coordinate;\n\n      for (let i = y; i < height / 2; i++) {\n        if (!isExistingPixel(x, i)) {\n          const redIndex = getIndex(x, i, width) + R_OFFSET;\n          const greenIndex = getIndex(x, i, width) + G_OFFSET;\n          const blueIndex = getIndex(x, i, width) + B_OFFSET;\n          imageData.data[redIndex] = newColor.r;\n          imageData.data[greenIndex] = newColor.g;\n          imageData.data[blueIndex] = newColor.b;\n\n          const currentKey = getXYKey(x, i);\n          existingPixels.set(currentKey, null);\n          numDetectedPixels++;\n        }\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\nfunction getBoundedPixelInfo(detectedPixels, { leftX, rightX }) {\n  const existingPixels = new Map();\n\n  let numDetectedPixels = 0;\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    if (x >= leftX && x <= rightX) {\n      const key = getXYKey(x, y);\n      existingPixels.set(key, coordinate);\n      numDetectedPixels++;\n    }\n  }\n\n  return {\n    numDetectedPixels,\n    existingPixels,\n  };\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} hex\n */\nfunction hexToRgb(hex) {\n  let red = 0,\n    green = 0,\n    blue = 0;\n  if (hex.length == 4) {\n    red = \"0x\" + hex[1] + hex[1];\n    green = \"0x\" + hex[2] + hex[2];\n    blue = \"0x\" + hex[3] + hex[3];\n  } else if (hex.length == 7) {\n    red = \"0x\" + hex[1] + hex[2];\n    green = \"0x\" + hex[3] + hex[4];\n    blue = \"0x\" + hex[5] + hex[6];\n  }\n  return { r: red, g: green, b: blue };\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\nexport { detectGrow, colorAreaWithBounds, getDetectedPixels };\n","// TODO to be implemented / fixed!\n\nconst WIDTH_PADDING = 50;\n\nasync function drawRotated(context, canvas, degrees, image) {\n  if (canvas == null || image == null || context == null) {\n    return;\n  }\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.save();\n  context.translate(canvas.width / 2, canvas.height / 2);\n  context.rotate(degreesToRadians(degrees));\n\n  const width = window.innerWidth - WIDTH_PADDING;\n  const height = (image.height / width) * width;\n  context.drawImage(image, -width / 2, -height / 2);\n  context.restore();\n}\n\nfunction drawAxis(context, canvas, axisCoordinates, image) {\n  if (canvas == null || image == null) {\n    return;\n  }\n  const { x: xOffset, y: yOffset } = axisCoordinates;\n  const { width: canvasWidth, height: canvasHeight } = canvas;\n  const originX = 0;\n  const originY = canvasHeight / 2 + yOffset;\n  context.beginPath();\n  context.moveTo(originX, originY + yOffset);\n  context.lineTo(originX + canvasWidth, originY + yOffset);\n  context.strokeStyle = \"#FF0000\";\n  context.stroke();\n}\n\nfunction degreesToRadians(degrees) {\n  return degrees * 0.01745;\n}\n\nfunction clearCanvasDrawing(context, width, height) {\n  if (context == null) {\n    return;\n  }\n  context.clearRect(0, 0, width, height);\n}\n\nfunction setWithImage(context, width, height, image) {\n  if (context == null) {\n    return;\n  }\n  context.drawImage(image, 0, 0, width, height);\n}\n\nexport { drawRotated, drawAxis, clearCanvasDrawing, setWithImage };\n","import * as Canvas from \"../../utils/Canvas\";\nimport * as ImageAnalysis from \"../../utils/ImageAnalysis\";\n\nasync function resetCanvas(\n  event,\n  canvasContext,\n  canvasWidth,\n  canvasHeight,\n  image,\n  setNumPixelsColored\n) {\n  event.preventDefault();\n  Canvas.setWithImage(canvasContext, canvasWidth, canvasHeight, image);\n  setNumPixelsColored(0);\n}\n\nasync function recolorDetection(image, canvasContext, recolorHex) {\n  const { width: detectionWidth, height: detectionHeight } = image;\n  const detectionDimensions = { detectionWidth, detectionHeight };\n\n  const [recoloredImageData, detectedPixels] = await ImageAnalysis.detectGrow(\n    canvasContext,\n    detectionDimensions,\n    recolorHex\n  );\n\n  canvasContext.putImageData(\n    recoloredImageData,\n    0,\n    0,\n    0,\n    0,\n    detectionWidth,\n    detectionHeight\n  );\n\n  return { canvasContext, detectedPixels };\n}\n\nexport { resetCanvas, recolorDetection };\n","import React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { Button } from \"react-bootstrap\";\nimport * as innerCanvasInfoReducer from \"../../redux/innerCanvasInfoReducer\";\nimport * as outerCanvasInfoReducer from \"../../redux/outerCanvasInfoReducer\";\nimport * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as utils from \"./utils\";\n\nfunction CanvasEffectButtonGroup(props) {\n  const dispatch = useDispatch();\n\n  // Redux\n  const image = useSelector((state) => state.image.source);\n  const isOuterEdit = useSelector((state) => state.canvasEdit.isOuterEdit);\n  const outerCanvasInfo = useSelector((state) => state.outerCanvasInfo);\n  const innerCanvasInfo = useSelector((state) => state.innerCanvasInfo);\n  const { width: canvasWidth, height: canvasHeight } = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  // Props\n  const { recolorHex } = props;\n\n  // local\n  const currentCanvasInfo = isOuterEdit ? outerCanvasInfo : innerCanvasInfo;\n\n  async function recolorDetection() {\n    let canvasContextInput = currentCanvasInfo.context;\n\n    const { canvasContext, detectedPixels } = await utils.recolorDetection(\n      image,\n      canvasContextInput,\n      recolorHex\n    );\n    const setContext = isOuterEdit\n      ? outerCanvasInfoReducer.setContext\n      : innerCanvasInfoReducer.setContext;\n    dispatch(setContext(canvasContext));\n\n    const setDetectedPixels = isOuterEdit\n      ? outerCanvasInfoReducer.setDetectedPixels\n      : innerCanvasInfoReducer.setDetectedPixels;\n    dispatch(setDetectedPixels(detectedPixels));\n  }\n\n  return (\n    <div>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={() => recolorDetection()}\n      >\n        Recolor detected\n      </Button>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={(event) => {\n          const setNumPixelsColored = isOuterEdit\n            ? outerCanvasInfoReducer.setNumColoredPixelsCallback(dispatch)\n            : innerCanvasInfoReducer.setNumColoredPixelsCallback(dispatch);\n\n          const setDetectedPixels = isOuterEdit\n            ? outerCanvasInfoReducer.setDetectedPixels\n            : innerCanvasInfoReducer.setDetectedPixels;\n          dispatch(setDetectedPixels([]));\n\n          utils.resetCanvas(\n            event,\n            currentCanvasInfo.context,\n            canvasWidth,\n            canvasHeight,\n            image,\n            setNumPixelsColored\n          );\n        }}\n      >\n        Reset\n      </Button>\n    </div>\n  );\n}\n\nexport default CanvasEffectButtonGroup;\n","import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { Form, Button } from \"react-bootstrap\";\nimport * as innerCanvasInfoReducer from \"../../redux/innerCanvasInfoReducer\";\nimport * as outerCanvasInfoReducer from \"../../redux/outerCanvasInfoReducer\";\nimport ColorToggler from \"../ColorToggler/ColorToggler\";\nimport CanvasEffectButtonGroup from \"../CanvasEffectButtonGroup/CanvasEffectButtonGroup\";\nimport \"./index.css\";\n\nfunction ImageAnalyzer(props) {\n  const dispatch = useDispatch();\n  const SLIDER_MIN = 0;\n  const SLIDER_MAX = 255;\n  const [detectionThreshold, setDetectionThreshold] = useState(125);\n\n  const changeDetectionThresholdBy = (value) => {\n    setDetectionThreshold((previous) => {\n      previous = parseInt(previous);\n      let newValue = previous + value;\n      newValue = newValue < 0 ? SLIDER_MIN : newValue;\n      newValue = newValue > SLIDER_MAX ? SLIDER_MAX : newValue;\n      return newValue;\n    });\n  };\n\n  const isOuterEdit = useSelector((state) => state.canvasEdit.isOuterEdit);\n\n  const innerSetRecolorHex = innerCanvasInfoReducer.setRecolorHex;\n  const outerSetRecolorHex = outerCanvasInfoReducer.setRecolorHex;\n  const setRecolorHex = isOuterEdit ? outerSetRecolorHex : innerSetRecolorHex;\n\n  const innerRecolorHex = useSelector(\n    (state) => state.innerCanvasInfo.recolorHex\n  );\n\n  const outerRecolorHex = useSelector(\n    (state) => state.outerCanvasInfo.recolorHex\n  );\n  const recolorHex = isOuterEdit ? outerRecolorHex : innerRecolorHex;\n\n  const canvasColorOptionsProps = {\n    detectionThreshold: [detectionThreshold, setDetectionThreshold],\n    ...props,\n    recolorHex,\n  };\n\n  return (\n    <div>\n      <div>\n        <ColorToggler />\n      </div>\n      <div>\n        <Form.Label>Recolor:</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"color\"\n          value={recolorHex}\n          onChange={(event) => {\n            const { value } = event.target;\n            dispatch(setRecolorHex(value));\n          }}\n        />\n      </div>\n      <div>\n        <Form.Label>Sensitivity: {detectionThreshold}</Form.Label>\n        <div className=\"d-flex mx-auto mb-3 justify-content-center\">\n          <Form.Control\n            className=\"input mx-2\"\n            type=\"range\"\n            min={SLIDER_MIN}\n            max={SLIDER_MAX}\n            value={detectionThreshold}\n            onChange={(event) => setDetectionThreshold(event.target.value)}\n          />\n        </div>\n        <div className=\"d-flex mx-auto justify-content-center\">\n          <Button\n            onClick={() => {\n              changeDetectionThresholdBy(-15);\n            }}\n            variant=\"outline-primary\"\n          >\n            -15\n          </Button>\n          <Button\n            className=\"mx-2\"\n            onClick={() => {\n              changeDetectionThresholdBy(-5);\n            }}\n            variant=\"outline-primary\"\n          >\n            -5\n          </Button>\n          <Button\n            className=\"mx-2\"\n            onClick={() => {\n              changeDetectionThresholdBy(-1);\n            }}\n            variant=\"outline-primary\"\n          >\n            -1\n          </Button>\n\n          <Button\n            className=\"mx-2\"\n            onClick={() => {\n              changeDetectionThresholdBy(1);\n            }}\n            variant=\"outline-primary\"\n          >\n            +1\n          </Button>\n\n          <Button\n            className=\"mx-2\"\n            onClick={() => {\n              changeDetectionThresholdBy(5);\n            }}\n            variant=\"outline-primary\"\n          >\n            +5\n          </Button>\n          <Button\n            onClick={() => {\n              changeDetectionThresholdBy(15);\n            }}\n            variant=\"outline-primary\"\n          >\n            +15\n          </Button>\n        </div>\n      </div>\n      <div className=\"m-2\">\n        <CanvasEffectButtonGroup {...canvasColorOptionsProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default ImageAnalyzer;\n","import React, { useEffect, useRef } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const dispatch = useDispatch();\n  const image = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    dispatch(setCanvasContext(context));\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null) {\n      return;\n    }\n\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image, drawWidth, drawHeight, canvasWidth, canvasHeight]);\n\n  return (\n    <div>\n      <canvas ref={canvasRef} className=\"border\" />\n    </div>\n  );\n}\n\nexport default Canvas;\n","export function setImage(source) {\n  return (dispatch) => {\n    const image = new Image();\n    image.onload = () => {\n      dispatch({ type: \"IMAGE_SET\", payload: image });\n    };\n    image.src = source;\n  };\n}\n\nexport function setImageCallback(dispatch) {\n  return (image) => {\n    dispatch({\n      type: \"IMAGE_SET\",\n      payload: image,\n    });\n  };\n}\n\nconst initialState = {\n  source: null,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"IMAGE_SET\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_COMBINE_CONTEXT\", payload: context };\n}\nexport function setNumColoredInnerPixels(numInnerPixels) {\n  return { type: \"SET_NUM_COLORED_INNER_PIXELS\", payload: numInnerPixels };\n}\nexport function setNumColoredOuterPixels(numOuterPixels) {\n  return { type: \"SET_NUM_COLORED_OUTER_PIXELS\", payload: numOuterPixels };\n}\nconst initialState = {\n  context: null,\n  numColoredOuterPixels: 0,\n  numColoredInnerPixels: 0,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_COMBINE_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_NUM_COLORED_INNER_PIXELS\":\n      return {\n        ...state,\n        numColoredInnerPixels: action.payload,\n      };\n    case \"SET_NUM_COLORED_OUTER_PIXELS\":\n      return {\n        ...state,\n        numColoredOuterPixels: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","import * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport * as CanvasUtils from \"../Canvas/utils\";\n\nfunction calculatedLossPercent(outerPixels, innerPixels) {\n  let percentage = (100 * (outerPixels - innerPixels)) / outerPixels;\n  return percentage.toFixed(4);\n}\n\nasync function combinedAnalysis(\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  canvasDimensions,\n  dispatch\n) {\n  const outerDetectedPixels = outerCanvasInfo.detectedPixels;\n  const innerDetectedPixels = innerCanvasInfo.detectedPixels;\n  const leftX = await findLeftCutOff(outerDetectedPixels, innerDetectedPixels);\n  const rightX = await findRightCutOff(\n    outerDetectedPixels,\n    innerDetectedPixels\n  );\n\n  const {\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  } = await ImageAnalysis.colorAreaWithBounds(\n    canvasDimensions,\n    outerCanvasInfo,\n    innerCanvasInfo,\n    combinedCanvasInfo,\n    { leftX, rightX }\n  );\n\n  combinedCanvasInfo.context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    canvasDimensions.width,\n    canvasDimensions.height\n  );\n  dispatch(combinedCanvasInfoReducer.setContext(combinedCanvasInfo.context));\n\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredInnerPixels(innerNumPixelsColored)\n  );\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredOuterPixels(outerNumPixelsColored)\n  );\n}\n\nasync function findLeftCutOff(outerDetectedPixels, innerDetectedPixels) {\n  let smallestOuter = Number.MAX_SAFE_INTEGER;\n  for (let coordinate of outerDetectedPixels) {\n    const { x } = coordinate;\n    smallestOuter = Math.min(smallestOuter, x);\n  }\n\n  let smallestInner = Number.MAX_SAFE_INTEGER;\n  for (let coordinate of innerDetectedPixels) {\n    const { x } = coordinate;\n    smallestInner = Math.min(smallestInner, x);\n  }\n\n  return Math.max(smallestOuter, smallestInner);\n}\nasync function findRightCutOff(outerDetectedPixels, innerDetectedPixels) {\n  let largestOuter = 0;\n  for (let coordinate of outerDetectedPixels) {\n    const { x } = coordinate;\n    largestOuter = Math.max(largestOuter, x);\n  }\n\n  let largestInner = 0;\n  for (let coordinate of innerDetectedPixels) {\n    const { x } = coordinate;\n    largestInner = Math.max(largestInner, x);\n  }\n\n  return Math.min(largestOuter, largestInner);\n}\n\nasync function downloadAll(contexts, { width, height }) {\n  for (let context of contexts) {\n    CanvasUtils.downloadImageData(\n      width,\n      height,\n      context.getImageData(0, 0, width, height)\n    );\n  }\n}\n\nexport { calculatedLossPercent, combinedAnalysis, downloadAll };\n","import React, { useEffect } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\n\nfunction AnalysisResults(props) {\n  const dispatch = useDispatch();\n\n  // State\n  const outerCanvasInfo = useSelector((state) => state.outerCanvasInfo);\n  const innerCanvasInfo = useSelector((state) => state.innerCanvasInfo);\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n  const imageSource = useSelector((state) => state.image.source);\n\n  const outerNumColoredPixels = combinedCanvasInfo.numColoredOuterPixels;\n  const innerNumColoredPixels = combinedCanvasInfo.numColoredInnerPixels;\n\n  // Child props\n  const canvasProps = {\n    ...props,\n    canvasContext: [\n      combinedCanvasInfo.context,\n      combinedCanvasInfoReducer.setContext,\n    ],\n  };\n\n  // useEffects\n  useEffect(() => {\n    if (imageSource) {\n      utils.combinedAnalysis(\n        outerCanvasInfo,\n        innerCanvasInfo,\n        combinedCanvasInfo,\n        canvasDimensions,\n        dispatch\n      );\n    }\n  }, [imageSource]);\n\n  return (\n    <div>\n      <Canvas {...canvasProps} />\n      <Button\n        className=\"my-2\"\n        variant=\"outline-primary\"\n        onClick={() => {\n          utils.combinedAnalysis(\n            outerCanvasInfo,\n            innerCanvasInfo,\n            combinedCanvasInfo,\n            canvasDimensions,\n            dispatch\n          );\n        }}\n      >\n        Recolor\n      </Button>\n      <div>\n        <div>\n          Calculated Loss %:{\" \"}\n          {utils.calculatedLossPercent(\n            outerNumColoredPixels,\n            innerNumColoredPixels\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default AnalysisResults;\n","import React, { useRef, useCallback, useEffect } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { withOrientationChange } from \"react-device-detect\";\nimport ImageAnalyzer from \"../../components/ImageAnalyzer/ImageAnalyzer\";\nimport Canvas from \"../../components/Canvas/Canvas\";\nimport Webcam from \"react-webcam\";\nimport * as imageReducer from \"../../redux/imageReducer\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { setContext as setInnerContext } from \"../../redux/innerCanvasInfoReducer\";\nimport { setContext as setOuterContext } from \"../../redux/outerCanvasInfoReducer\";\nimport AnalysisResults from \"../../components/AnalysisResults/AnalysisResults\";\nimport { downloadJpegInClient } from \"./utils\";\nimport \"./index.css\";\nimport target from \"../../assets/target/thick.png\";\nimport sampleChart from \"../../assets/black-red.jpeg\";\n\nfunction Manual(props) {\n  // Setup\n  const dispatch = useDispatch();\n\n  // State\n  const videoConstraints = useSelector(\n    (state) => state.videoReducer.videoConstraints\n  );\n  const image = useSelector((state) => state.image.source);\n  const innerCanvasContext = useSelector(\n    (state) => state.innerCanvasInfo.context\n  );\n  const outerCanvasContext = useSelector(\n    (state) => state.outerCanvasInfo.context\n  );\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  // Remove this later, just for testing\n  useEffect(() => {\n    dispatch(imageReducer.setImage(sampleChart));\n  }, []);\n\n  // Props\n  const { isPortrait } = props;\n\n  // Ref\n  const webcamRef = useRef(null);\n  const captureContainerRef = useRef(null);\n\n  // Other hooks\n  const capture = useCallback(() => {\n    const screenshot = webcamRef.current.getScreenshot();\n    dispatch(imageReducer.setImage(screenshot));\n    downloadJpegInClient(screenshot, \"image\");\n  }, [webcamRef]);\n\n  // Children props setup\n  const outerCanvasProps = {\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n    canvasContext: [outerCanvasContext, setOuterContext],\n  };\n\n  const innerCanvasProps = {\n    ...outerCanvasProps,\n    canvasContext: [innerCanvasContext, setInnerContext],\n  };\n\n  const analysisResultsProps = {\n    ...innerCanvasProps,\n  };\n\n  return (\n    <div className=\"App\">\n      {isPortrait && <h5>Please rotate your device</h5>}\n\n      {!isPortrait && (\n        <div\n          className=\"d-flex justify-content-around align-items-center\"\n          ref={captureContainerRef}\n        >\n          <div style={{ position: \"relative\", float: \"top\" }}>\n            <Webcam\n              audio={false}\n              height={videoConstraints.height}\n              ref={webcamRef}\n              screenshotFormat=\"image/jpeg\"\n              width={videoConstraints.width}\n              videoConstraints={videoConstraints}\n            />\n            <div className=\"overlay\">\n              <img\n                className=\"target\"\n                style={{ height: videoConstraints.height }}\n                src={target}\n              />\n            </div>\n          </div>\n          <div className=\"my-3\">\n            <Button onClick={() => capture()} variant=\"outline-primary\">\n              Take picture\n            </Button>\n          </div>\n        </div>\n      )}\n\n      <Canvas {...outerCanvasProps} />\n      <Canvas {...innerCanvasProps} />\n      <ImageAnalyzer />\n\n      <div>\n        <AnalysisResults {...analysisResultsProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default withOrientationChange(Manual);\n","import * as DomHelper from \"../../utils/DomHelper\";\nasync function saveSelectedImage(event, setImage) {\n  const image = await DomHelper.getImageFromInput(event);\n  setImage(image);\n}\n\nfunction getCurrentViewportWidth() {\n  return Math.max(\n    document.documentElement.clientWidth || 0,\n    window.innerWidth || 0\n  );\n}\n\nfunction getProportionalX(originalX, originalY, proportionalY) {\n  return (originalX * proportionalY) / originalY;\n}\n\nfunction downloadJpegInClient(imageData, fileName) {\n  const a = document.createElement(\"a\");\n  a.href = imageData;\n  a.download = fileName + \".jpeg\";\n  a.click();\n}\n\nexport {\n  saveSelectedImage,\n  getCurrentViewportWidth,\n  getProportionalX,\n  downloadJpegInClient,\n};\n","import * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport CanvasDataHelper from \"../../models/canvasData\";\n\nasync function fullAnalysis(image, combinedCanvasInfo) {\n  const { width, height } = image;\n  const dimensions = {\n    detectionWidth: width,\n    detectionHeight: height,\n  };\n\n  // setup\n  const { context } = combinedCanvasInfo;\n  context.drawImage(image, 0, 0, width, height);\n  const imageData = context.getImageData(0, 0, width, height);\n\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: dimensions.detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  // Get \"max\" intense coordinate\n  const maxCoor = await findMax(canvasData, dimensions);\n  const maxDetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    maxCoor\n  );\n\n  // find next Max\n  const nextMaxCoor = await findNextMax(\n    maxCoor,\n    maxDetectedPixels,\n    canvasData,\n    width,\n    height\n  );\n\n  const nextMaxdetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    nextMaxCoor\n  );\n\n  const allDetectedPixels = [...maxDetectedPixels, ...nextMaxdetectedPixels];\n\n  for (let coor of allDetectedPixels) {\n    canvasData.recolor(coor, { r: 0, g: 0, b: 255 });\n  }\n\n  context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    dimensions.detectionWidth,\n    dimensions.detectionHeight\n  );\n\n  return Promise.resolve([context]);\n}\n\nasync function findNextMax(maxCoor, detectedPixels, canvasData, width, height) {\n  const photoOriginY = height / 2;\n  const distanceFromOrigin = Math.abs(maxCoor.y - photoOriginY);\n  const distanceFromTop = maxCoor.y;\n\n  // If the already found coor's distance from the bottom (origin) is less than the tops then\n  // it's closer to the bottom and we are searching from top to bottom\n  const isTopToBottomSearch = distanceFromOrigin < distanceFromTop;\n  const middleX = width / 2;\n\n  // If we are search from top to bottom it means the current max is the bottom\n  // Hence, from the detected bottom line when need to find the biggest y as the boundary\n  let boundary = isTopToBottomSearch ? Number.MAX_VALUE : Number.MIN_VALUE;\n  const boundaryComparator = isTopToBottomSearch ? Math.min : Math.max;\n\n  for (let { y } of detectedPixels) {\n    boundary = boundaryComparator(boundary, y);\n  }\n\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  let y = isTopToBottomSearch ? 0 : photoOriginY;\n\n  while (y !== boundary) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n    if (isTopToBottomSearch) {\n      y++;\n    } else {\n      y--;\n    }\n  }\n  return coor;\n}\n\nasync function findMax(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = 0; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\nfunction calculatedLossPercent(outerPixels, innerPixels) {\n  let percentage = (100 * (outerPixels - innerPixels)) / outerPixels;\n  return percentage.toFixed(4);\n}\n\nasync function combinedAnalysis(\n  outerCanvasInfo,\n  innerCanvasInfo,\n  combinedCanvasInfo,\n  canvasDimensions,\n  dispatch\n) {\n  const outerDetectedPixels = outerCanvasInfo.detectedPixels;\n  const innerDetectedPixels = innerCanvasInfo.detectedPixels;\n  const leftX = await findLeftCutOff(outerDetectedPixels, innerDetectedPixels);\n  const rightX = await findRightCutOff(\n    outerDetectedPixels,\n    innerDetectedPixels\n  );\n\n  const {\n    imageData,\n    outerNumPixelsColored,\n    innerNumPixelsColored,\n  } = await ImageAnalysis.colorAreaWithBounds(\n    canvasDimensions,\n    outerCanvasInfo,\n    innerCanvasInfo,\n    combinedCanvasInfo,\n    { leftX, rightX }\n  );\n\n  combinedCanvasInfo.context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    canvasDimensions.width,\n    canvasDimensions.height\n  );\n  dispatch(combinedCanvasInfoReducer.setContext(combinedCanvasInfo.context));\n\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredInnerPixels(innerNumPixelsColored)\n  );\n  dispatch(\n    combinedCanvasInfoReducer.setNumColoredOuterPixels(outerNumPixelsColored)\n  );\n}\n\nasync function findLeftCutOff(outerDetectedPixels, innerDetectedPixels) {\n  let smallestOuter = Number.MAX_SAFE_INTEGER;\n  for (let coordinate of outerDetectedPixels) {\n    const { x } = coordinate;\n    smallestOuter = Math.min(smallestOuter, x);\n  }\n\n  let smallestInner = Number.MAX_SAFE_INTEGER;\n  for (let coordinate of innerDetectedPixels) {\n    const { x } = coordinate;\n    smallestInner = Math.min(smallestInner, x);\n  }\n\n  return Math.max(smallestOuter, smallestInner);\n}\nasync function findRightCutOff(outerDetectedPixels, innerDetectedPixels) {\n  let largestOuter = 0;\n  for (let coordinate of outerDetectedPixels) {\n    const { x } = coordinate;\n    largestOuter = Math.max(largestOuter, x);\n  }\n\n  let largestInner = 0;\n  for (let coordinate of innerDetectedPixels) {\n    const { x } = coordinate;\n    largestInner = Math.max(largestInner, x);\n  }\n\n  return Math.min(largestOuter, largestInner);\n}\n\nexport { calculatedLossPercent, combinedAnalysis, fullAnalysis };\n","import React from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\n\nfunction AnalysisResults(props) {\n  const dispatch = useDispatch();\n\n  // State\n  const outerCanvasInfo = useSelector((state) => state.outerCanvasInfo);\n  const innerCanvasInfo = useSelector((state) => state.innerCanvasInfo);\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n  const imageSource = useSelector((state) => state.image.source);\n\n  const outerNumColoredPixels = combinedCanvasInfo.numColoredOuterPixels;\n  const innerNumColoredPixels = combinedCanvasInfo.numColoredInnerPixels;\n\n  // Child props\n  const canvasProps = {\n    ...props,\n    canvasContext: [\n      combinedCanvasInfo.context,\n      combinedCanvasInfoReducer.setContext,\n    ],\n  };\n\n  async function fullAnalysis() {\n    const combinedCanvasContext = await utils.fullAnalysis(\n      imageSource,\n      combinedCanvasInfo\n    );\n    // don't have to do this to update\n    //dispatch(combinedCanvasInfoReducer.setContext(combinedCanvasContext));\n  }\n\n  return (\n    <div>\n      <div className=\"d-flex justify-content-around align-items-center\">\n        <Canvas {...canvasProps} />\n\n        <div>\n          <Button\n            className=\"my-2\"\n            variant=\"outline-primary\"\n            onClick={fullAnalysis}\n          >\n            Full analysis\n          </Button>\n\n          <div>\n            Calculated Loss %:{\" \"}\n            {utils.calculatedLossPercent(\n              outerNumColoredPixels,\n              innerNumColoredPixels\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default AnalysisResults;\n","import React, { useRef, useCallback, useEffect } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport { withOrientationChange } from \"react-device-detect\";\nimport Webcam from \"react-webcam\";\nimport * as imageReducer from \"../../redux/imageReducer\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport AutoReanalyze from \"../../components/AutoReanalyze/AutoReanalyze\";\nimport target from \"../../assets/target/thick.png\";\nimport \"./index.css\";\n//import sampleChart from \"../../assets/top-max.jpeg\";\n//import sampleChart from \"../../assets/image-5.jpeg\";\n\nfunction Auto(props) {\n  // Setup\n  const dispatch = useDispatch();\n\n  // Redux\n  const videoConstraints = useSelector(\n    (state) => state.videoReducer.videoConstraints\n  );\n  const image = useSelector((state) => state.image.source);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n\n  // Props\n  const { isPortrait } = props;\n\n  // Ref\n  const webcamRef = useRef(null);\n  const captureContainerRef = useRef(null);\n\n  // UseEffect - Remove this later, just for testing\n  useEffect(() => {\n    //dispatch(imageReducer.setImage(sampleChart));\n  }, []);\n\n  // Other hooks\n  const capture = useCallback(() => {\n    const screenshot = webcamRef.current.getScreenshot();\n    dispatch(imageReducer.setImage(screenshot));\n  }, [webcamRef]);\n\n  // Children props setup\n  const autoReanalyzeProps = {\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n  };\n\n  return (\n    <div className=\"App\">\n      {isPortrait && <h5>Please rotate your device</h5>}\n\n      {!isPortrait && (\n        <div\n          className=\"d-flex justify-content-around align-items-center\"\n          ref={captureContainerRef}\n        >\n          <div style={{ position: \"relative\", float: \"top\" }}>\n            <Webcam\n              audio={false}\n              height={videoConstraints.height}\n              ref={webcamRef}\n              screenshotFormat=\"image/jpeg\"\n              width={videoConstraints.width}\n              videoConstraints={videoConstraints}\n            />\n            <div className=\"overlay\">\n              <img\n                className=\"target\"\n                style={{ height: videoConstraints.height }}\n                src={target}\n              />\n            </div>\n          </div>\n          <div className=\"my-3\">\n            <Button onClick={() => capture()} variant=\"outline-primary\">\n              Take picture\n            </Button>\n          </div>\n        </div>\n      )}\n      <div>\n        <AutoReanalyze {...autoReanalyzeProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default withOrientationChange(Auto);\n","import React from \"react\";\nimport Manual from \"../Manual\";\nimport Auto from \"../Auto\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  NavLink,\n} from \"react-router-dom\";\nfunction Home() {\n  return (\n    <>\n      <Router>\n        <div>\n          <nav>\n            <ul>\n              <li>\n                <NavLink to=\"/auto\" activeClassName=\"selected\">\n                  Auto\n                </NavLink>\n              </li>\n              <li>\n                <NavLink to=\"/manual\" activeClassName=\"selected\">\n                  Manual\n                </NavLink>\n              </li>\n            </ul>\n          </nav>\n          <Switch>\n            <Route path=\"/manual\">\n              <Manual />\n            </Route>\n            <Route path=\"/auto\">\n              <Auto />\n            </Route>\n          </Switch>\n        </div>\n      </Router>\n    </>\n  );\n}\n\nexport default Home;\n","import React from \"react\";\nimport Home from \"../../pages/Home\";\n\nfunction App() {\n  return (\n    <>\n      <Home />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export function setCanvasDimensions(dimensions) {\n  return { type: \"SET_CANVAS_DIMENSIONS\", payload: dimensions };\n}\n\nconst initialState = {\n  canvasDimensions: {\n    width: 450,\n    height: 320,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_CANVAS_DIMENSIONS\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","const initialState = {\n  videoConstraints: {\n    width: 450,\n    height: 320,\n    facingMode: { exact: \"environment\" },\n    //facingMode: \"user\",\n    audio: false,\n    imageSmoothing: true,\n    screenshotQuality: 1,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    default:\n      return state;\n  }\n}\n","import { combineReducers, createStore, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport imageReducer from \"./imageReducer\";\nimport canvasEditReducer from \"./canvasEditReducer\";\nimport innerCanvasInfoReducer from \"./innerCanvasInfoReducer\";\nimport outerCanvasInfoReducer from \"./outerCanvasInfoReducer\";\nimport combinedCanvasInfoReducer from \"./combinedCanvasInfoReducer\";\nimport canvasSettingsReducer from \"./canvasSettingsReducer\";\nimport videoReducer from \"./videoReducer\";\n\nconst rootReducer = combineReducers({\n  image: imageReducer,\n  canvasEdit: canvasEditReducer,\n  innerCanvasInfo: innerCanvasInfoReducer,\n  outerCanvasInfo: outerCanvasInfoReducer,\n  combinedCanvasInfo: combinedCanvasInfoReducer,\n  canvasSettings: canvasSettingsReducer,\n  videoReducer: videoReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App/index\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Provider } from \"react-redux\";\nimport store from \"./redux\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}