{"version":3,"sources":["redux/imageReducer.js","redux/combinedCanvasInfoReducer.js","components/Canvas/Canvas.js","models/coordinate.js","models/canvasData.js","components/Adjuster/ImageAnalysis.js","components/Adjuster/utils.js","components/Adjuster/Adjuster.js","utils/DomHelper.js","components/Main/Main.js","components/App/index.tsx","serviceWorker.js","redux/canvasEditReducer.js","redux/innerCanvasInfoReducer.js","redux/outerCanvasInfoReducer.js","redux/canvasSettingsReducer.js","redux/videoReducer.js","redux/index.js","index.js","assets/target/circle.png"],"names":["initialState","source","image","setContext","context","type","payload","setNumColoredInnerPixels","numInnerPixels","setNumColoredOuterPixels","numOuterPixels","numColoredOuterPixels","numColoredInnerPixels","Canvas","props","dispatch","useDispatch","canvasDimensions","canvasWidth","canvasHeight","drawDimensions","drawWidth","drawHeight","canvasContext","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","width","height","drawImage","className","ref","Coordinate","x","y","this","CanvasDataHelper","imageArray","redIndex","getIndex","greenIndex","blueIndex","redValue","greenValue","blueValue","alphaIndex","r","g","b","rgb","rgbPixel","alphaValue","alpha","pixelAtCoordinate","newColor","Number","newR","newG","newB","tintDelta","start","end","colorSpace","require","DeltaE","getDetectedPixels","canvasData","seedCoordinate","edgeCanvas","dimensions","threshold","a","detectedPixels","push","queue","visited","Set","add","length","currentCoor","pop","getXYKey","neighbors","getNeighbors","neighborCoor","key","isWithinBoundary","has","isSimiliar","retinexWhiteBalance","maxR","maxG","maxB","Math","sqrt","pow","max","rCoeff","bCoeff","parseInt","recolor","suspect","seedRgb","seedLab","lab","seedLabObj","L","A","B","suspectRgb","suspectLab","suspectLabObj","getDeltaE00","coor","neighborsDelta","coordinate","delta","deltaX","deltaY","updateImageData","leftX","rightX","numDetectedPixels","coloredPixels","i","verticalCoordinate","tint","String","fullAnalysis","combinedCanvasInfo","detectionWidth","detectionHeight","edgeContext","getEdgeCanvasHelper","imageData","getImageData","ImageAnalysis","data","findMax","maxCoor","maxDetectedPixels","findNextMax","nextMaxCoor","nextMaxdetectedPixels","topDetectedPixels","bottomDetectedPixels","findCutOff","cuttOff","top","left","right","topPixelsCount","bottom","bottomPixelsCount","putImageData","Promise","resolve","photoOriginY","middleX","distanceFromOrigin","abs","distanceFromTop","boundary","isTopToBottomSearch","intensity","MIN_SAFE_INTEGER","value","topPixels","bottomPixels","bounds","findBounds","min","out","MAX_SAFE_INTEGER","undefined","data_type","jsfeat","U8_t","img_u8","matrix_t","imgproc","grayscale","gaussian_blur","canny","data_u32","Uint32Array","buffer","cols","rows","pix","AnalysisResults","outerPixels","useSelector","state","imageSource","imageForDownload","thresholdState","setThreshold","outerNumColoredPixels","innerNumColoredPixels","webcamContainerRef","setIsCameraOn","cameraState","canvasProps","combinedCanvasInfoReducer","changeThresholdBy","previous","utils","Card","Button","variant","onClick","window","scrollTo","offsetTop","toFixed","now","Date","fileName","document","createElement","href","download","click","DomHelper","toDateString","Body","Title","e","icon","size","style","display","withOrientationChange","useState","isCameraOn","videoConstraints","videoReducer","canvasSettings","isPortrait","webcamRef","autoAnalyzeContainerRef","capture","screenshot","getScreenshot","Image","onload","src","imageReducer","autoReanalyzeProps","popover","Popover","id","Content","OverlayTrigger","trigger","placement","overlay","audio","screenshotFormat","target","Adjuster","library","fab","faMinus","faPlus","faCamera","faQuestionCircle","App","Boolean","location","hostname","match","isOuterEdit","recoloredImageData","numColoredPixels","recolorHex","facingMode","exact","imageSmoothing","screenshotQuality","rootReducer","combineReducers","action","canvasEdit","innerCanvasInfo","outerCanvasInfo","store","createStore","applyMiddleware","thunk","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","module","exports"],"mappings":"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","file":"static/js/main.3d4553d9.chunk.js","sourcesContent":["export function setImageOnload(source) {\n  return (dispatch) => {\n    const image = new Image();\n    image.onload = () => {\n      dispatch({ type: \"IMAGE_SOURCE_SET\", payload: image });\n    };\n    image.src = source;\n  };\n}\n\nexport function setImage(image) {\n  return {\n    type: \"IMAGE_SET\",\n    payload: image,\n  };\n}\n\nconst initialState = {\n  source: null,\n  image: null,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"IMAGE_SOURCE_SET\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    case \"IMAGE_SET\":\n      return {\n        ...state,\n        image: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_COMBINE_CONTEXT\", payload: context };\n}\nexport function setNumColoredInnerPixels(numInnerPixels) {\n  return { type: \"SET_NUM_COLORED_INNER_PIXELS\", payload: numInnerPixels };\n}\nexport function setNumColoredOuterPixels(numOuterPixels) {\n  return { type: \"SET_NUM_COLORED_OUTER_PIXELS\", payload: numOuterPixels };\n}\nconst initialState = {\n  context: null,\n  numColoredOuterPixels: 0,\n  numColoredInnerPixels: 0,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_COMBINE_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_NUM_COLORED_INNER_PIXELS\":\n      return {\n        ...state,\n        numColoredInnerPixels: action.payload,\n      };\n    case \"SET_NUM_COLORED_OUTER_PIXELS\":\n      return {\n        ...state,\n        numColoredOuterPixels: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","import React, { useEffect, useRef } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const dispatch = useDispatch();\n  const image = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    dispatch(setCanvasContext(context));\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null) {\n      return;\n    }\n\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image, drawWidth, drawHeight, canvasWidth, canvasHeight]);\n\n  return (\n    <div className=\"mx-auto\">\n      <canvas ref={canvasRef} />\n    </div>\n  );\n}\n\nexport default Canvas;\n","export default class Coordinate {\n  constructor({ x, y }) {\n    this.x = x;\n    this.y = y;\n  }\n}\n","/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\nconst ALPHA_OFFSET = 3;\n\nexport default class CanvasDataHelper {\n  constructor({ canvasWidth, imageArray }) {\n    this.canvasWidth = canvasWidth;\n    this.imageArray = imageArray;\n  }\n\n  rgbPixel({ x, y }) {\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    const redValue = this.imageArray[redIndex];\n    const greenValue = this.imageArray[greenIndex];\n    const blueValue = this.imageArray[blueIndex];\n    if (redValue !== 0 && greenValue !== 0 && blueValue !== 0) {\n      const alphaIndex = getIndex(x, y, this.canvasWidth) + ALPHA_OFFSET;\n      const alphaValue = this.imageArray[alphaIndex];\n    }\n    return { r: redValue, g: greenValue, b: blueValue };\n  }\n\n  rgbaPixel({ x, y }) {\n    const rgb = this.rgbPixel({ x, y });\n    const alphaIndex = getIndex(x, y, this.canvasWidth) + ALPHA_OFFSET;\n    const alphaValue = this.imageArray[alphaIndex];\n    rgb.alpha = alphaValue;\n    return rgb;\n  }\n\n  recolor(pixelAtCoordinate, newColor) {\n    const { r, g, b } = newColor;\n    const { x, y } = pixelAtCoordinate;\n\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    this.imageArray[redIndex] = Number(r);\n    this.imageArray[greenIndex] = Number(g);\n    this.imageArray[blueIndex] = Number(b);\n  }\n\n  tint(pixelAtCoordinate, newColor) {\n    const { r: newR, g: newG, b: newB } = newColor;\n\n    const { x, y } = pixelAtCoordinate;\n\n    const redIndex = getIndex(x, y, this.canvasWidth) + R_OFFSET;\n    const greenIndex = getIndex(x, y, this.canvasWidth) + G_OFFSET;\n    const blueIndex = getIndex(x, y, this.canvasWidth) + B_OFFSET;\n\n    const r = this.imageArray[redIndex];\n    const g = this.imageArray[greenIndex];\n    const b = this.imageArray[blueIndex];\n\n    this.imageArray[redIndex] += this.tintDelta(r, newR);\n    this.imageArray[greenIndex] += this.tintDelta(g, newG);\n    this.imageArray[blueIndex] += this.tintDelta(b, newB);\n  }\n\n  tintDelta(start, end) {\n    const tintFactor = 3;\n    return (end - start) / 3;\n  }\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n","import Coordinate from \"../../models/coordinate\";\nimport CanvasDataHelper from \"../../models/canvasData\";\nimport * as math from \"mathjs\";\n\nconst colorSpace = require(\"color-space\");\nconst DeltaE = require(\"delta-e\");\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\nconst red = { r: 255, g: 0, b: 0 };\nconst green = { r: 0, g: 255, b: 0 };\nconst blue = { r: 0, g: 0, b: 255 };\nasync function getDetectedPixels(\n  canvasData,\n  seedCoordinate,\n  edgeCanvas,\n  dimensions,\n  threshold\n) {\n  const { x, y } = seedCoordinate;\n  const detectedPixels = [];\n  detectedPixels.push(seedCoordinate);\n\n  let queue = [];\n  queue.push(seedCoordinate);\n  const visited = new Set();\n  visited.add(seedCoordinate);\n  while (queue.length > 0) {\n    const currentCoor = queue.pop();\n\n    const key = getXYKey(currentCoor.x, currentCoor.y);\n    const neighbors = getNeighbors(currentCoor);\n\n    for (let neighborCoor of neighbors) {\n      const key = getXYKey(neighborCoor.x, neighborCoor.y);\n\n      if (\n        isWithinBoundary(neighborCoor, dimensions) &&\n        !visited.has(key) &&\n        isSimiliar(neighborCoor, canvasData, seedCoordinate, threshold)\n      ) {\n        queue.push(neighborCoor);\n        detectedPixels.push(neighborCoor);\n      }\n      visited.add(key);\n    }\n  }\n\n  return detectedPixels;\n}\n\nasync function greyWorldTheoryWhiteBalance(canvasData, dimensions) {\n  const { width, height } = dimensions;\n\n  let totalR = 0;\n  let totalG = 0;\n  let totalB = 0;\n\n  let count = 0;\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height / 2; y++) {\n      const rgb = canvasData.rgbPixel({ x, y });\n      totalR += rgb.r;\n      totalG += rgb.g;\n      totalB += rgb.b;\n      count++;\n    }\n  }\n\n  const averageR = totalR / count;\n  const averageB = totalB / count;\n  const averageG = totalG / count;\n  const rCoeff = averageR / averageG;\n  const bCoeff = averageB / averageG;\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height / 2; y++) {\n      const rgb = canvasData.rgbPixel({ x, y });\n      const r = parseInt(rgb.r * rCoeff);\n      const g = rgb.g;\n      const b = parseInt(rgb.b * bCoeff);\n      canvasData.recolor({ x, y }, { r, g, b });\n    }\n  }\n}\n\nasync function medianWhiteBalance(canvasData, dimensions) {\n  const { width, height } = dimensions;\n\n  const freq = new Map();\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height / 2; y++) {\n      const rgb = canvasData.rgbPixel({ x, y });\n      const key = \"\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b;\n      const value = freq.has(key) ? freq.get(key) : 0;\n      freq.set(key, value + 1);\n    }\n  }\n\n  let highestFreq = 0;\n  let highestFreqKey = 0;\n  freq.forEach((value, key, map) => {\n    if (value >= highestFreq) {\n      highestFreqKey = key;\n    }\n  });\n\n  const [rS, gS, bS] = highestFreqKey.split(\",\");\n  const rMed = parseInt(rS);\n  const gMed = parseInt(gS);\n  const bMed = parseInt(bS);\n\n  const rCoeff = rMed / gMed;\n  const bCoeff = bMed / gMed;\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height / 2; y++) {\n      const rgb = canvasData.rgbPixel({ x, y });\n      const r = parseInt(rgb.r * rCoeff);\n      const g = rgb.g;\n      const b = parseInt(rgb.b * bCoeff);\n      canvasData.recolor({ x, y }, { r, g, b });\n    }\n  }\n}\n\nasync function retinexWhiteBalance(canvasData, dimensions) {\n  const { width, height } = dimensions;\n\n  let maxR = 0;\n  let maxG = 0;\n  let maxB = 0;\n\n  let count = 0;\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height / 2; y++) {\n      // Only count pixels within the circle\n      const distance = Math.sqrt(Math.pow(x - 200, 2) + Math.pow(y - 200, 2));\n\n      if (distance < 188) {\n        const rgb = canvasData.rgbPixel({ x, y });\n        maxR = Math.max(rgb.r, maxR);\n        maxG = Math.max(rgb.g, maxG);\n        maxB = Math.max(rgb.b, maxB);\n        count++;\n      }\n    }\n  }\n\n  const rCoeff = maxG / maxR;\n  const bCoeff = maxG / maxB;\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height / 2; y++) {\n      const rgb = canvasData.rgbPixel({ x, y });\n      const r = parseInt(rgb.r * rCoeff);\n      const g = rgb.g;\n      const b = parseInt(rgb.b * bCoeff);\n      canvasData.recolor({ x, y }, { r, g, b });\n    }\n  }\n}\n\nfunction isSimiliar(suspect, canvasData, seedCoordinate, threshold) {\n  const seedRgb = canvasData.rgbPixel(seedCoordinate);\n  const seedLab = colorSpace.rgb.lab([seedRgb.r, seedRgb.g, seedRgb.b]);\n  const seedLabObj = { L: seedLab[0], A: seedLab[1], B: seedLab[2] };\n  const suspectRgb = canvasData.rgbPixel(suspect);\n\n  const suspectLab = colorSpace.rgb.lab([\n    suspectRgb.r,\n    suspectRgb.g,\n    suspectRgb.b,\n  ]);\n\n  const suspectLabObj = {\n    L: suspectLab[0],\n    A: suspectLab[1],\n    B: suspectLab[2],\n  };\n\n  return DeltaE.getDeltaE00(seedLabObj, suspectLabObj) < threshold;\n}\n\nfunction isWithinBoundary(coor, dimensions) {\n  const { x, y } = coor;\n  return x > 0 && x < dimensions.width && y > 0 && y < dimensions.height;\n}\n\nfunction isEdge(coor, canvasData) {\n  const rgbPixel = canvasData.rgbPixel(coor);\n  // if all black then it is a edge pixel\n  return rgbPixel.r === 255 && rgbPixel.g === 255 && rgbPixel.b === 255;\n}\n\nconst neighborsDelta = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, -1],\n  [0, 1],\n  [1, -1],\n  [1, 0],\n  [1, 1],\n];\nfunction getNeighbors(coordinate) {\n  const neighbors = [];\n  const { x, y } = coordinate;\n\n  for (let delta of neighborsDelta) {\n    const [deltaX, deltaY] = delta;\n    neighbors.push(new Coordinate({ x: deltaX + x, y: deltaY + y }));\n  }\n\n  return neighbors;\n}\n\nasync function updateImageData(\n  canvasData,\n  { leftX, rightX, height },\n  recolor,\n  detectedPixels\n) {\n  let numDetectedPixels = 0;\n  const coloredPixels = new Set();\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n\n    // Go down a vertical line, stop slightly less than the middle\n    for (let i = y; i < height / 2; i++) {\n      const key = getXYKey(x, i);\n      const verticalCoordinate = { x, y: i };\n\n      // Color this pixel only if it has not been colored before and is within bounds\n      if (!coloredPixels.has(key) && leftX <= x && x <= rightX) {\n        coloredPixels.add(key);\n        canvasData.tint(verticalCoordinate, recolor);\n        numDetectedPixels++;\n      }\n    }\n  }\n\n  return numDetectedPixels;\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\nexport {\n  getDetectedPixels,\n  updateImageData,\n  isEdge,\n  greyWorldTheoryWhiteBalance,\n  retinexWhiteBalance,\n  medianWhiteBalance,\n};\n","import * as ImageAnalysis from \"./ImageAnalysis\";\nimport CanvasDataHelper from \"../../models/canvasData\";\nimport jsfeat from \"jsfeat\";\n\n// Consider that some non chart area will be capture, thus start the calculations from a padding, not from the very top\nconst START_HEIGHT = 12;\n\n// If the y coor is greater than this is number it is lower, thus within, the 5% rule\nconst WITHIN_HEIGHT = 182;\n\nasync function fullAnalysis(image, combinedCanvasInfo, canvasRef, threshold) {\n  const { width, height } = image;\n  const dimensions = {\n    detectionWidth: width,\n    detectionHeight: height,\n  };\n\n  // Edge canvas stuff\n  const { current: canvas } = canvasRef;\n  const edgeContext = canvas.getContext(\"2d\");\n  const edgeCanvas = await getEdgeCanvasHelper(image, edgeContext);\n\n  /*\n   * Setup\n   */\n\n  const { context } = combinedCanvasInfo;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: dimensions.detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  /*\n   * White balance\n   */\n\n  ImageAnalysis.retinexWhiteBalance(canvasData, { width, height });\n\n  /*\n   * Extremas\n   */\n\n  // Global extrema we look for the most \"X\" of a pixel, for ex. red\n  const maxCoor = await findMax(canvasData, dimensions);\n  const maxDetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    maxCoor,\n    edgeCanvas,\n    { width, height },\n    threshold\n  );\n\n  // Now we look for the next \"X\" of a pixel that is some distance away from the one before\n  const nextMaxCoor = await findNextMax(maxCoor, canvasData, width, height);\n\n  const nextMaxdetectedPixels = await ImageAnalysis.getDetectedPixels(\n    canvasData,\n    nextMaxCoor,\n    edgeCanvas,\n    { width, height },\n    threshold\n  );\n\n  /*\n   * Assign top / bottom\n   */\n\n  // assume that max coor is above next max\n  let topDetectedPixels = maxDetectedPixels;\n  let bottomDetectedPixels = nextMaxdetectedPixels;\n\n  // Means that max coor is not above next max\n  if (maxCoor.y > nextMaxCoor.y) {\n    // Switch them\n    [topDetectedPixels, bottomDetectedPixels] = [\n      bottomDetectedPixels,\n      topDetectedPixels,\n    ];\n  }\n\n  /*\n   * Recolor\n   */\n\n  //  Cutoff finding\n  const cuttOff = await findCutOff(topDetectedPixels, bottomDetectedPixels);\n\n  // Recoloring\n  const recolor = { r: 0, g: 255, b: 0 };\n  const topPixelsCount = await ImageAnalysis.updateImageData(\n    canvasData,\n    { leftX: cuttOff.top.left.x, rightX: cuttOff.top.right.x, height },\n    recolor,\n    topDetectedPixels\n  );\n\n  const bottomPixelsCount = await ImageAnalysis.updateImageData(\n    canvasData,\n    { leftX: cuttOff.bottom.left.x, rightX: cuttOff.bottom.right.x, height },\n    { r: 0, g: 0, b: 255 },\n    bottomDetectedPixels\n  );\n\n  context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    dimensions.detectionWidth,\n    dimensions.detectionHeight\n  );\n\n  return Promise.resolve({ topPixelsCount, bottomPixelsCount });\n}\n\nasync function findNextMax(maxCoor, canvasData, width, height) {\n  // Setup\n  const photoOriginY = height / 2;\n  const middleX = width / 2;\n\n  const distanceFromOrigin = Math.abs(maxCoor.y - photoOriginY);\n  const distanceFromTop = maxCoor.y;\n\n  // If the already found coor's distance from the bottom (origin) is less than the tops then\n  // it's closer to the bottom and we are searching from top to bottom\n  const isTopToBottomSearch = distanceFromOrigin < distanceFromTop;\n  let boundary = distanceFromTop;\n\n  // Ensure that boundary is least some distance between the top and bottom so it won't be mistaken\n  boundary += isTopToBottomSearch ? -5 : 5;\n\n  let coor = { x: middleX };\n  let intensity = Number.MIN_SAFE_INTEGER;\n\n  let y = isTopToBottomSearch ? START_HEIGHT : photoOriginY;\n\n  while (y !== boundary) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n\n    if (value > intensity) {\n      coor = { y: y, x: middleX };\n      intensity = value;\n    }\n    isTopToBottomSearch ? y++ : y--;\n  }\n  return coor;\n}\n\nasync function findMax(canvasData, { detectionWidth, detectionHeight }) {\n  const middleX = detectionWidth / 2;\n  let coor = { x: middleX };\n  let intensity = 0;\n\n  // We use detection height / 2 so we only detect for the upper half of the image\n  for (let y = START_HEIGHT; y < detectionHeight / 2; y++) {\n    const coordinate = { x: middleX, y };\n    const rgbPixel = canvasData.rgbPixel(coordinate);\n\n    const value = rgbPixel.r * 2 - rgbPixel.b - rgbPixel.g;\n    if (value > intensity) {\n      coor.y = y;\n      intensity = value;\n    }\n  }\n\n  return coor;\n}\n\nfunction calculatedLossPercent(outerPixels, innerPixels) {\n  let percentage = (100 * (outerPixels - innerPixels)) / outerPixels;\n  return percentage.toFixed(2);\n}\n\n/**\n * We consider something \"within\" if the end\n *\n *\n * Divide the chart up into 4 quadrants. Let quadrant I be the top right and quadrant II be the top left.\n * The logic for I and II are the same but just applied to one side\n *\n * There are 6 possible scenarios\n * 1. Both top and bottom ends are \"Within\"\n * 2. Top is not within and bottom is, top horizontally extends beyond the bottom end (Top longer)\n *\n *   Top longer | Top within | Bottom within\n * 3. yes         yes           no\n * 4. no          no            yes\n * 5. yes         no            no\n * 6. no          no            no\n * Case 3-6 we just \"double bound\" the cutoff see function\n *\n * @param {*} topPixels\n * @param {*} bottomPixels\n */\nasync function findCutOff(topPixels, bottomPixels) {\n  const bounds = findBounds(topPixels, bottomPixels);\n\n  /*\n   * Leftside\n   */\n\n  // both are NOT within\n  if (\n    !(\n      bounds.top.left.y > WITHIN_HEIGHT && bounds.bottom.left.y > WITHIN_HEIGHT\n    ) &&\n    // bottom is within and the top is more left\n    !(\n      bounds.bottom.left.y > WITHIN_HEIGHT &&\n      bounds.top.left.x < bounds.bottom.left.x\n    )\n  ) {\n    // Cap the cutoff to the more limiting of the x on the left side\n    const left = Math.max(bounds.top.left.x, bounds.bottom.left.x);\n    bounds.top.left.x = left;\n    bounds.bottom.left.x = left;\n  }\n\n  /*\n   * Rightside\n   */\n\n  // both are NOT within\n  if (\n    !(\n      bounds.top.right.y > WITHIN_HEIGHT &&\n      bounds.bottom.right.y > WITHIN_HEIGHT\n    ) &&\n    // bottom is within and the top is more left\n    !(\n      bounds.bottom.right.y > WITHIN_HEIGHT &&\n      bounds.top.right.x > bounds.bottom.right.x\n    )\n  ) {\n    const right = Math.min(bounds.top.right.x, bounds.bottom.right.x);\n    bounds.top.right.x = right;\n    bounds.bottom.right.x = right;\n  }\n  return bounds;\n}\n\n/**\n * Find the left and right most\n * @param {*} topPixels\n * @param {*} bottomPixels\n */\nfunction findBounds(topPixels, bottomPixels) {\n  const out = {\n    top: {\n      left: {\n        x: Number.MAX_SAFE_INTEGER,\n        y: undefined,\n      },\n      right: {\n        x: 0,\n        y: undefined,\n      },\n    },\n    bottom: {\n      left: {\n        x: Number.MAX_SAFE_INTEGER,\n        y: undefined,\n      },\n      right: {\n        x: 0,\n        y: undefined,\n      },\n    },\n  };\n\n  for (let coordinate of topPixels) {\n    const { x, y } = coordinate;\n    if (x < out.top.left.x) {\n      out.top.left.x = x;\n      out.top.left.y = y;\n    }\n    if (x > out.top.right.x) {\n      out.top.right.x = x;\n      out.top.right.y = y;\n    }\n  }\n\n  for (let coordinate of bottomPixels) {\n    const { x, y } = coordinate;\n    if (x < out.bottom.left.x) {\n      out.bottom.left.x = x;\n      out.bottom.left.y = y;\n    }\n    if (x > out.bottom.right.x) {\n      out.bottom.right.x = x;\n      out.bottom.right.y = y;\n    }\n  }\n\n  return out;\n}\n\n/* Not in use  */\nasync function getEdgeCanvasHelper(image, context) {\n  const { width, height } = image;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const columns = 450,\n    rows = 320,\n    data_type = jsfeat.U8_t;\n  let img_u8 = new jsfeat.matrix_t(columns, rows, data_type);\n  jsfeat.imgproc.grayscale(imageData.data, width, height, img_u8);\n\n  let r = 3; // 0 -4\n  let kernel_size = (r + 1) << 1;\n  let low_threshold = 120; // 1 - 127\n  let high_threshold = 120; // 1 - 127\n\n  jsfeat.imgproc.gaussian_blur(img_u8, img_u8, kernel_size, 0);\n\n  jsfeat.imgproc.canny(img_u8, img_u8, low_threshold, high_threshold);\n\n  // render result back to canvas\n  var data_u32 = new Uint32Array(imageData.data.buffer);\n  var alpha = 0xff << 24;\n  var i = img_u8.cols * img_u8.rows,\n    pix = 0;\n  while (--i >= 0) {\n    pix = img_u8.data[i];\n    data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;\n  }\n\n  // Draw canny\n  context.putImageData(imageData, 0, 0, 0, 0, width, height);\n\n  const edgeCanvas = new CanvasDataHelper({\n    canvasWidth: width,\n    imageArray: imageData.data,\n  });\n\n  return edgeCanvas;\n}\n\nasync function colorEdges(image, combinedCanvasInfo) {\n  const { width, height } = image;\n  const dimensions = {\n    detectionWidth: width,\n    detectionHeight: height,\n  };\n\n  const { context } = combinedCanvasInfo;\n  context.drawImage(image, 0, 0, width, height);\n  let imageData = context.getImageData(0, 0, width, height);\n\n  const canvasData = new CanvasDataHelper({\n    canvasWidth: dimensions.detectionWidth,\n    imageArray: imageData.data,\n  });\n\n  for (let y = 5; y < height / 2; y++) {\n    for (let x = 5; x < width - 10; x++) {\n      const coor = { x, y };\n      if (ImageAnalysis.isEdge(coor, canvasData)) {\n        canvasData.recolor(coor, { r: 0, g: 255, b: 0 });\n      }\n    }\n  }\n\n  context.putImageData(\n    imageData,\n    0,\n    0,\n    0,\n    0,\n    dimensions.detectionWidth,\n    dimensions.detectionHeight\n  );\n}\n\nexport { calculatedLossPercent, fullAnalysis, colorEdges, getEdgeCanvasHelper };\n","import React, { useRef, useEffect, useState } from \"react\";\nimport { Button, Card } from \"react-bootstrap\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as combinedCanvasInfoReducer from \"../../redux/combinedCanvasInfoReducer\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\nimport * as DomHelper from \"../../utils/DomHelper\";\n\nfunction AnalysisResults(props) {\n  const dispatch = useDispatch();\n\n  // State\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n  const imageSource = useSelector((state) => state.image.source);\n  const imageForDownload = useSelector((state) => state.image.image);\n  const [threshold, setThreshold] = props.thresholdState;\n\n  const outerNumColoredPixels = combinedCanvasInfo.numColoredOuterPixels;\n  const innerNumColoredPixels = combinedCanvasInfo.numColoredInnerPixels;\n\n  // Props\n  const { webcamContainerRef } = props;\n  const [, setIsCameraOn] = props.cameraState;\n\n  // Child props\n  const canvasProps = {\n    ...props,\n    canvasContext: [\n      combinedCanvasInfo.context,\n      combinedCanvasInfoReducer.setContext,\n    ],\n  };\n\n  const canvasRef = useRef(null);\n\n  function changeThresholdBy(value) {\n    setThreshold((previous) => Math.max(0, previous + value));\n  }\n\n  useEffect(() => {\n    if (imageSource) {\n      fullAnalysis();\n    }\n  }, [imageSource, threshold]);\n\n  async function fullAnalysis() {\n    const { topPixelsCount, bottomPixelsCount } = await utils.fullAnalysis(\n      imageSource,\n      combinedCanvasInfo,\n      canvasRef,\n      threshold\n    );\n\n    dispatch(\n      combinedCanvasInfoReducer.setNumColoredOuterPixels(topPixelsCount)\n    );\n    dispatch(\n      combinedCanvasInfoReducer.setNumColoredInnerPixels(bottomPixelsCount)\n    );\n  }\n\n  return (\n    <Card>\n      {imageSource && <h2 className=\"card-title\">Results</h2>}\n      <div>\n        <Canvas {...canvasProps} />\n        {imageSource && (\n          <div\n            className={`d-flex justify-content-around align-items-center mb-4`}\n          >\n            <div>\n              <Button\n                variant=\"outline-primary\"\n                onClick={() => {\n                  setIsCameraOn(true);\n                  window.scrollTo(0, webcamContainerRef.current.offsetTop);\n                }}\n              >\n                Retake picture\n              </Button>\n\n              <div>\n                <h3 className=\"mt-4\">\n                  Loss:{\" \"}\n                  {utils.calculatedLossPercent(\n                    outerNumColoredPixels,\n                    innerNumColoredPixels\n                  )}\n                  %\n                </h3>\n                <div className=\"mt-4\">\n                  <Button\n                    variant=\"outline-primary\"\n                    onClick={() => {\n                      const now = new Date();\n                      DomHelper.downloadJpegInClient(\n                        imageForDownload,\n                        now.toDateString()\n                      );\n                    }}\n                  >\n                    Download original\n                  </Button>{\" \"}\n                </div>\n              </div>\n            </div>\n\n            <Card>\n              <Card.Body>\n                <Card.Title>Sensitivity: {threshold}</Card.Title>\n                <div className=\"container\">\n                  <div className=\"row justify-content-around mb-3\">\n                    <Button\n                      onClick={(e) => {\n                        changeThresholdBy(-1);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"minus\" size=\"1x\" />\n                    </Button>\n                    <Button\n                      onClick={(e) => {\n                        changeThresholdBy(1);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"plus\" size=\"1x\" />\n                    </Button>\n                  </div>\n                  <div className=\"row justify-content-between\">\n                    <Button\n                      className=\"mr-1\"\n                      onClick={(e) => {\n                        changeThresholdBy(-3);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"minus\" size=\"1x\" />\n                      {\"  \"}\n                      <FontAwesomeIcon icon=\"minus\" size=\"1x\" />\n                    </Button>\n                    <Button\n                      onClick={(e) => {\n                        changeThresholdBy(3);\n                      }}\n                    >\n                      <FontAwesomeIcon icon=\"plus\" size=\"1x\" />\n                      {\"  \"}\n                      <FontAwesomeIcon icon=\"plus\" size=\"1x\" />\n                    </Button>\n                  </div>\n                </div>\n              </Card.Body>\n            </Card>\n          </div>\n        )}\n      </div>\n\n      {/* Used for edge canvas */}\n      <canvas style={{ display: \"none\" }} ref={canvasRef} />\n    </Card>\n  );\n}\n\nexport default AnalysisResults;\n","/**\n * Return the image with it's source loaded from an file input\n * @param {*} event\n */\nasync function getImageFromInput(event) {\n  return new Promise((resolve, reject) => {\n    if (event.target.files && event.target.files.item(0)) {\n      const imageSource = URL.createObjectURL(event.target.files[0]);\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.src = imageSource;\n      return;\n    }\n    reject(\"No file selected\");\n  });\n}\n\nfunction downloadJpegInClient(imageData, fileName) {\n  const a = document.createElement(\"a\");\n  a.href = imageData;\n  a.download = fileName + \".jpeg\";\n  a.click();\n}\n\nfunction setFromInput(event, setter) {\n  const { value } = event.target;\n  setter(value);\n}\n\nexport { getImageFromInput, setFromInput, downloadJpegInClient };\n","import React, { useRef, useEffect, useState } from \"react\";\nimport { Button, Card, OverlayTrigger, Popover } from \"react-bootstrap\";\nimport { withOrientationChange } from \"react-device-detect\";\nimport Webcam from \"react-webcam\";\nimport * as imageReducer from \"../../redux/imageReducer\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport Adjuster from \"../Adjuster/Adjuster\";\nimport target from \"../../assets/target/circle.png\";\nimport \"./index.css\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\n// For the analysis\nconst START_THRESHOLD = 20;\nlet imageForDownload = null;\n\nfunction Auto(props) {\n  // Setup\n  const dispatch = useDispatch();\n  const [threshold, setThreshold] = useState(START_THRESHOLD);\n  const [isCameraOn, setIsCameraOn] = useState(true);\n\n  // Redux\n  const videoConstraints = useSelector(\n    (state) => state.videoReducer.videoConstraints\n  );\n  const image = useSelector((state) => state.image.source);\n  const canvasDimensions = useSelector(\n    (state) => state.canvasSettings.canvasDimensions\n  );\n  const combinedCanvasInfo = useSelector((state) => state.combinedCanvasInfo);\n\n  // Props\n  const { isPortrait } = props;\n\n  // Ref\n  const webcamContainerRef = useRef(null);\n  const webcamRef = useRef(null);\n  const autoAnalyzeContainerRef = useRef(null);\n\n  // Set a default image for debuggin bad images\n  useEffect(() => {\n    //dispatch(imageReducer.setImageOnload(sampleChart));\n  }, []);\n\n  const capture = () => {\n    if (!isCameraOn) {\n      setIsCameraOn(true);\n      return;\n    }\n\n    // reset threshold\n    setThreshold(START_THRESHOLD);\n\n    const screenshot = webcamRef.current.getScreenshot();\n    dispatch(imageReducer.setImageOnload(screenshot));\n    dispatch(imageReducer.setImage(screenshot));\n    window.scrollTo(0, autoAnalyzeContainerRef.current.offsetTop);\n\n    setIsCameraOn(false);\n\n    imageForDownload = screenshot;\n    // Download image\n    //DomHelper.downloadJpegInClient(screenshot, \"fail\");\n  };\n\n  // Children props setup\n  const autoReanalyzeProps = {\n    webcamRef,\n    webcamContainerRef,\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n    isPortrait,\n    thresholdState: [threshold, setThreshold],\n    cameraState: [isCameraOn, setIsCameraOn],\n  };\n\n  const popover = (\n    <Popover id=\"popover-basic\">\n      <Popover.Content>\n        Draw your chart with red sharpie. Align the red target's circle\n        concentrically with the chart's smallest circle that still encompasses\n        all of the the drawn lines for increased accuracy. Also ensure the\n        target cross is aligned with the chart. Camera focus will happen\n        automatically. Tap the (?) again to close this popover.\n      </Popover.Content>\n    </Popover>\n  );\n  return (\n    <div className=\"App mt-2\">\n      <h2 className=\"card-title\" style={{ display: \"inline\" }}>\n        Capture chart{\" \"}\n      </h2>\n      <OverlayTrigger trigger=\"click\" placement=\"bottom\" overlay={popover}>\n        <FontAwesomeIcon icon=\"question-circle\" size=\"2x\" />\n      </OverlayTrigger>\n      <Card className=\"mt-4\">\n        <div className=\"mx-auto\">\n          <div className=\"capture-container mx-auto\" ref={webcamContainerRef}>\n            {isCameraOn && (\n              <>\n                <Webcam\n                  ref={webcamRef}\n                  audio={false}\n                  height={videoConstraints.height}\n                  screenshotFormat=\"image/jpeg\"\n                  width={videoConstraints.width}\n                  videoConstraints={videoConstraints}\n                />\n                <div className=\"overlay\">\n                  <img\n                    className=\"target\"\n                    //width -20 leaves some padding on the left and right side\n                    style={{ width: videoConstraints.width - 20 }}\n                    src={target}\n                  />\n                </div>\n              </>\n            )}\n          </div>\n        </div>\n        <div className=\"my-2 z-top mx-auto\">\n          <Button className=\"capture-button\" onClick={() => capture()}>\n            <FontAwesomeIcon icon=\"camera\" size=\"3x\" />\n          </Button>\n        </div>\n      </Card>\n\n      <div className=\"mt-4\" ref={autoAnalyzeContainerRef}>\n        <Adjuster {...autoReanalyzeProps} />\n      </div>\n      <br />\n      <br />\n      <br />\n    </div>\n  );\n}\n\nexport default withOrientationChange(Auto);\n","import React from \"react\";\nimport Main from \"../Main/Main\";\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport { fab } from \"@fortawesome/free-brands-svg-icons\";\nimport { faMinus, faPlus, faCamera, faQuestionCircle } from \"@fortawesome/free-solid-svg-icons\";\n\nlibrary.add(fab, faMinus, faPlus, faCamera, faQuestionCircle);\nfunction App() {\n  return (\n    <>\n      <Main />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export function toggleIsOuterEdit() {\n  return { type: \"TOGGLE_IS_OUTER_EDIT\" };\n}\n\nconst initialState = {\n  isOuterEdit: true,\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"TOGGLE_IS_OUTER_EDIT\":\n      return {\n        ...state,\n        isOuterEdit: !state.isOuterEdit,\n      };\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_INNER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_INNER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_INNER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_INNER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_INNER_RECOLOR_HEX\", payload: hex };\n}\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#00FF00\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_INNER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_INNER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_INNER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_INNER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_INNER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n\n    default:\n      return state;\n  }\n}\n","export function setContext(context) {\n  return { type: \"SET_OUTER_CONTEXT\", payload: context };\n}\nexport function setRecoloredImageData(recoloredImageData) {\n  return {\n    type: \"SET_OUTER_RECOLORED_IMAGE_DATA\",\n    payload: recoloredImageData,\n  };\n}\nexport function setDetectedPixels(detectedPixels) {\n  return { type: \"SET_OUTER_DETECTED_PIXELS\", payload: detectedPixels };\n}\nexport function setNumColoredPixelsCallback(dispatch) {\n  return (numColoredPixels) => {\n    dispatch(setNumColoredPixels(numColoredPixels));\n  };\n}\n\nexport function setNumColoredPixels(numColoredPixels) {\n  return { type: \"SET_OUTER_NUM_COLORED_PIXELS\", payload: numColoredPixels };\n}\n\nexport function setRecolorHex(hex) {\n  return { type: \"SET_OUTER_RECOLOR_HEX\", payload: hex };\n}\n\nconst initialState = {\n  context: null,\n  recoloredImageData: null,\n  numColoredPixels: 0,\n  detectedPixels: [],\n  recolorHex: \"#FFA500\",\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_OUTER_CONTEXT\":\n      return {\n        ...state,\n        context: action.payload,\n      };\n    case \"SET_OUTER_RECOLORED_IMAGE_DATA\":\n      return {\n        ...state,\n        recoloredImageData: action.payload,\n      };\n    case \"SET_OUTER_DETECTED_PIXELS\":\n      return {\n        ...state,\n        detectedPixels: action.payload,\n      };\n    case \"SET_OUTER_NUM_COLORED_PIXELS\":\n      return {\n        ...state,\n        numColoredPixels: action.payload,\n      };\n\n    case \"SET_OUTER_RECOLOR_HEX\":\n      return {\n        ...state,\n        recolorHex: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","export function setCanvasDimensions(dimensions) {\n  return { type: \"SET_CANVAS_DIMENSIONS\", payload: dimensions };\n}\n\nconst initialState = {\n  canvasDimensions: {\n    width: 400,\n    height: 400,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SET_CANVAS_DIMENSIONS\":\n      return {\n        ...state,\n        source: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n","const initialState = {\n  videoConstraints: {\n\n    // These numbers should match those in the canvas settings\n    width: 400,\n    height: 400,\n    facingMode: { exact: \"environment\" },\n    //facingMode: \"user\",\n    audio: false,\n    imageSmoothing: true,\n    screenshotQuality: 1,\n  },\n};\n\nexport default function reducer(state = initialState, action) {\n  switch (action.type) {\n    default:\n      return state;\n  }\n}\n","import { combineReducers, createStore, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport imageReducer from \"./imageReducer\";\nimport canvasEditReducer from \"./canvasEditReducer\";\nimport innerCanvasInfoReducer from \"./innerCanvasInfoReducer\";\nimport outerCanvasInfoReducer from \"./outerCanvasInfoReducer\";\nimport combinedCanvasInfoReducer from \"./combinedCanvasInfoReducer\";\nimport canvasSettingsReducer from \"./canvasSettingsReducer\";\nimport videoReducer from \"./videoReducer\";\n\nconst rootReducer = combineReducers({\n  image: imageReducer,\n  canvasEdit: canvasEditReducer,\n  innerCanvasInfo: innerCanvasInfoReducer,\n  outerCanvasInfo: outerCanvasInfoReducer,\n  combinedCanvasInfo: combinedCanvasInfoReducer,\n  canvasSettings: canvasSettingsReducer,\n  videoReducer: videoReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App/index\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Provider } from \"react-redux\";\nimport store from \"./redux\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/circle.9036c121.png\";"],"sourceRoot":""}