{"version":3,"sources":["components/FileInput/FileInput.js","utils/DomHelper.js","components/ColorToggler/ColorToggler.js","components/ImageAligner/utils.js","components/ImageAligner/ImageAligner.js","utils/ImageAnalysis.js","utils/Canvas.js","components/CanvasColorOptions/utils.js","components/CanvasColorOptions/CanvasColorOptions.js","components/ImageAnalyzer/ImageAnalyzer.js","components/Canvas/Canvas.js","components/App/utils.js","components/App/App.js","serviceWorker.js","index.js"],"names":["inputStyle","width","FileInput","props","label","accept","onChangeHandler","Form","File","type","style","custom","onChange","event","getImageFromInput","a","Promise","resolve","reject","target","files","item","imageSource","URL","createObjectURL","image","Image","onload","src","ColorToggler","isRedEdit","setIsRedEdit","redToggler","prev","Button","active","className","variant","onClick","incrementBy","e","stateSetter","value","preventDefault","previous","incrementOrginCoordinates","xIncrement","yIncrement","x","y","ImageAligner","rotationDegrees","setRotationDegrees","axisCoordinates","setAxisCoordinates","isRed","threshold","r","g","b","isBlue","detect","detectionDimensions","imageData","isColor","recolorHex","detectionWidth","detectionHeight","hexToRgb","redRecolor","greenRecolor","blueRecolor","detectedPixels","originalPixels","data","slice","redIndex","getIndex","greenIndex","blueIndex","redValue","greenValue","blueValue","Number","push","colorArea","canvasContext","newColorHex","height","getImageData","numPixelsColored","maxY","existingPixels","Map","isExistingPixel","containsXYKeyIn","getXYKey","coordinate","Math","max","key","set","i","String","getKey","map","has","hex","red","green","blue","length","setWithImage","context","drawImage","canvasWidth","canvasHeight","setNumPixelsColored","Canvas","CanvasEffectButtonGroup","useState","setDetectedPixels","detectionThreshold","setNumPixelsColoredRed","numPixelsColoredRed","setNumPixelsColoredBlue","numPixelsColoredBlue","canvasDimensions","isColorDetector","ImageAnalysis","recoloredImageData","putImageData","numPixels","recolorDetection","recolorCanvasArea","utils","ImageAnalyzer","setDetectionThreshold","setRecolorHex","canvasColorOptionsProps","imageAlignerProps","Label","Control","setter","DomHelper","min","drawDimensions","drawWidth","drawHeight","setCanvasContext","canvasRef","useRef","useEffect","current","getContext","canvas","ref","setImage","App","originalX","originalY","canvasContextRed","setCanvasContextRed","canvasContextBlue","setCanvasContextBlue","document","documentElement","clientWidth","window","innerWidth","redCanvasProps","blueCanvasProps","imageAnalyzerProps","Accordion","defaultActiveKey","Card","Header","Toggle","as","eventKey","Collapse","Body","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"6WAmBA,IAAMA,EAAa,CACjBC,MAAO,SAGMC,EApBf,SAAmBC,GAAQ,IACjBC,EAAmCD,EAAnCC,MAAOC,EAA4BF,EAA5BE,OAAQC,EAAoBH,EAApBG,gBACvB,OACE,6BACE,kBAACC,EAAA,EAAKC,KAAN,CACEC,KAAK,OACLJ,OAAQA,EACRD,MAAOA,EACPM,MAAOV,EACPW,QAAM,EACNC,SAAU,SAACC,GAAD,OAAWP,EAAgBO,Q,gCCT9BC,E,8EAAf,WAAiCD,GAAjC,SAAAE,EAAA,+EACS,IAAIC,SAAQ,SAACC,EAASC,GAC3B,GAAIL,EAAMM,OAAOC,OAASP,EAAMM,OAAOC,MAAMC,KAAK,GAAI,CACpD,IAAMC,EAAcC,IAAIC,gBAAgBX,EAAMM,OAAOC,MAAM,IACrDK,EAAQ,IAAIC,MAGlB,OAFAD,EAAME,OAAS,kBAAMV,EAAQQ,SAC7BA,EAAMG,IAAMN,GAGdJ,EAAO,wBATX,4C,sBCyBeW,MA3Bf,SAAsB1B,GAAQ,IAAD,cACOA,EAAM2B,UADb,GACpBA,EADoB,KACTC,EADS,KAErBC,EAAa,WACjBD,GAAa,SAACE,GAAD,OAAWA,MAE1B,OACE,6BACE,mDACA,kBAACC,EAAA,EAAD,CACEC,OAAQL,EACRM,UAAU,OACVC,QAAQ,iBACRC,QAASN,GAJX,OAQA,kBAACE,EAAA,EAAD,CACEC,QAASL,EACTO,QAAQ,kBACRC,QAASN,GAHX,U,MClBN,SAASO,EAAYC,EAAGC,EAAaC,GACnCF,EAAEG,iBACFF,GAAY,SAACG,GAAD,OAAcA,EAAWF,KAGvC,SAASG,EAA0BL,EAAGM,EAAYC,EAAYN,GAC5DD,EAAEG,iBACFF,GAAY,YAAe,IAAZO,EAAW,EAAXA,EAAGC,EAAQ,EAARA,EAChB,MAAO,CAAED,EAAGA,EAAIF,EAAYG,EAAGA,EAAIF,MC0CxBG,MA5Cf,SAAsB/C,GAAQ,IAAD,cACmBA,EAAMgD,gBADzB,GACpBA,EADoB,KACHC,EADG,mBAEmBjD,EAAMkD,gBAFzB,GAEpBA,EAFoB,KAEHC,EAFG,KAG3B,OACE,6BACE,6BACE,8CAAoBD,EAAgBJ,GACpC,8CACA,kBAACf,EAAA,EAAD,CACEE,UAAU,OACVE,QAAS,SAACzB,GAAD,OACPgC,EAA0BhC,EAAO,GAAI,EAAGyC,KAH5C,WAQA,kBAACpB,EAAA,EAAD,CACEE,UAAU,OACVE,QAAS,SAACzB,GAAD,OACPgC,EAA0BhC,EAAO,EAAG,EAAGyC,KAH3C,cAUF,6BACE,qDAA2BH,GAC3B,kBAACjB,EAAA,EAAD,CACEE,UAAU,OACVE,QAAS,SAACzB,GAAD,OAAW0B,EAAY1B,EAAOuC,GAAqB,KAF9D,eAMA,kBAAClB,EAAA,EAAD,CACEE,UAAU,OACVE,QAAS,SAACzB,GAAD,OAAW0B,EAAY1B,EAAOuC,EAAoB,KAF7D,mB,QCpCR,SAASG,EAAMC,GACb,OAAO,SAACC,EAAGC,EAAGC,GAAP,OAAiB,EAAJF,GAASC,EAAIC,GAAK,IAAMH,GAO9C,SAASI,EAAOJ,GACd,OAAO,SAACC,EAAGC,EAAGC,GAAP,OAAiB,EAAJA,GAASD,EAAID,GAAK,IAAMD,G,SAiB/BK,E,oFAAf,WAAsBC,EAAqBC,EAAWC,EAASC,GAA/D,+CAAAlD,EAAA,sDAOE,IANQmD,EAAoCJ,EAApCI,eAAgBC,EAAoBL,EAApBK,gBAD1B,EAEkDC,EAASH,GAF3D,mBAESI,EAFT,KAEqBC,EAFrB,KAEmCC,EAFnC,KAGQC,EAAiB,GAEjBC,EAAiBV,EAAUW,KAAKC,QAE7B1B,EAAI,EAAGA,EAAIkB,EAAiBlB,IACnC,IAASD,EAAI,EAAGA,EAAIkB,EAAgBlB,IAC5B4B,EAAWC,EAAS7B,EAAGC,EAAGiB,GApBrB,EAqBLY,EAAaD,EAAS7B,EAAGC,EAAGiB,GApBvB,EAqBLa,EAAYF,EAAS7B,EAAGC,EAAGiB,GApBtB,EAsBLc,EAAWP,EAAeG,GAC1BK,EAAaR,EAAeK,GAC5BI,EAAYT,EAAeM,GAE7Bf,EAAQgB,EAAUC,EAAYC,KAChCnB,EAAUW,KAAKE,GAAYO,OAAOd,GAClCN,EAAUW,KAAKI,GAAcK,OAAOb,GACpCP,EAAUW,KAAKK,GAAaI,OAAOZ,GACnCC,EAAeY,KAAK,CAAEpC,EAAGA,EAAGC,EAAGA,KArBvC,yBA0BSjC,QAAQC,QAAQ,CAAC8C,EAAWS,KA1BrC,4C,+BAoCea,E,oFAAf,aAEEC,EACAC,EACAf,GAJF,qEAAAzD,EAAA,sDACId,EADJ,EACIA,MAAOuF,EADX,EACWA,OADX,EAMkDpB,EAASmB,GAN3D,mBAMSlB,EANT,KAMqBC,EANrB,KAMmCC,EANnC,KAOQR,EAAYuB,EAAcG,aAAa,EAAG,EAAGxF,EAAOuF,GACtDE,EAAmB,EACnBC,EAAO,EAELC,EAAiB,IAAIC,IACrBC,EAAkBC,EAAgBC,EAAUJ,GAZpD,cAcyBpB,GAdzB,IAcE,2BAASyB,EAA8B,QAC7BjD,EAASiD,EAATjD,EAAGC,EAAMgD,EAANhD,EACX0C,EAAOO,KAAKC,IAAIlD,EAAG0C,GACbS,EAAMJ,EAAShD,EAAGC,GACxB2C,EAAeS,IAAID,EAAK,MACxBV,IAnBJ,4CAsByBlB,GAtBzB,IAsBE,2BAEE,IAFOyB,EAA8B,QAC7BjD,EAASiD,EAATjD,EAAGC,EAAMgD,EAANhD,EACFqD,EAAIrD,EAAGqD,EAAIX,EAAMW,IACnBR,EAAgB9C,EAAGsD,KAChB1B,EAAWC,EAAS7B,EAAGsD,EAAGrG,GAzEvB,EA0EH6E,EAAaD,EAAS7B,EAAGsD,EAAGrG,GAzEzB,EA0EH8E,EAAYF,EAAS7B,EAAGsD,EAAGrG,GAzExB,EA0ET8D,EAAUW,KAAKE,GAAYP,EAC3BN,EAAUW,KAAKI,GAAcR,EAC7BP,EAAUW,KAAKK,GAAaR,EAEtB6B,EAAMJ,EAAShD,EAAGsD,GACxBV,EAAeS,IAAID,EAAK,MACxBV,KAnCR,uDAwCS1E,QAAQC,QAAQ,CAAC8C,EAAW2B,KAxCrC,6C,sBAgDA,SAASM,EAAShD,EAAGC,GACnB,OAAOsD,OAAOvD,GAAKuD,OAAOtD,GAS5B,SAAS8C,EAAgBS,EAAQC,GAC/B,OAAO,SAACzD,EAAGC,GACT,IAAMmD,EAAMI,EAAOxD,EAAGC,GACtB,OAAOwD,EAAIC,IAAIN,IAQnB,SAAShC,EAASuC,GAChB,IAAIC,EAAM,EACRC,EAAQ,EACRC,EAAO,EAUT,OATkB,GAAdH,EAAII,QACNH,EAAM,KAAOD,EAAI,GAAKA,EAAI,GAC1BE,EAAQ,KAAOF,EAAI,GAAKA,EAAI,GAC5BG,EAAO,KAAOH,EAAI,GAAKA,EAAI,IACJ,GAAdA,EAAII,SACbH,EAAM,KAAOD,EAAI,GAAKA,EAAI,GAC1BE,EAAQ,KAAOF,EAAI,GAAKA,EAAI,GAC5BG,EAAO,KAAOH,EAAI,GAAKA,EAAI,IAEtB,CAACC,EAAKC,EAAOC,GAStB,SAASjC,EAAS7B,EAAGC,EAAGhD,GACtB,OAAyB,GAAjB+C,EAAIC,EAAIhD,GCjHlB,SAAS+G,EAAaC,EAAShH,EAAOuF,EAAQ/D,GAC7B,MAAXwF,GAGJA,EAAQC,UAAUzF,EAAO,EAAG,EAAGxB,EAAOuF,G,4CC/CxC,WACE3E,EACAyE,EACA6B,EACAC,EACA3F,EACA4F,GANF,SAAAtG,EAAA,sDAQEF,EAAM8B,iBACN2E,EAAoBhC,EAAe6B,EAAaC,EAAc3F,GAC9D4F,EAAoB,GAVtB,4C,sBC8GeE,MA3Gf,SAAiCpH,GAAQ,IAAD,EACMqH,mBAAS,IADf,mBAC/BhD,EAD+B,KACfiD,EADe,KAE9BxD,EAAe9D,EAAf8D,WACDnC,EAH+B,YAGlB3B,EAAM2B,UAHY,MAK/BwD,EAL+B,YAKdnF,EAAMmF,cALQ,MAM/BoC,EAN+B,YAMTvH,EAAMuH,mBANG,MAO7BC,EAP6B,YAOHxH,EAAMyH,oBAPH,MAQ7BC,EAR6B,YAQF1H,EAAM2H,qBARJ,MAU/BrG,EAV+B,YAUtBtB,EAAMsB,MAVgB,QAWAtB,EAAM4H,iBAApCZ,EAX8B,EAW9BA,YAAaC,EAXiB,EAWjBA,aAXiB,4CAatC,4CAAArG,EAAA,6DACiBmD,EAA4CzC,EAAnDxB,MAA+BkE,EAAoB1C,EAA5B+D,OACzB1B,EAAsB,CAAEI,iBAAgBC,mBACxCJ,EAAYuB,EAAcG,aAC9B,EACA,EACAvB,EACAC,GAGI6D,EAAkBlG,EACpBmG,EAAoBP,GACpBO,EAAqBP,GAZ3B,SAcqDO,EACjDnE,EACAC,EACAiE,EACA/D,GAlBJ,mCAcSiE,EAdT,KAc6B1D,EAd7B,KAqBEc,EAAc6C,aACZD,EACA,EACA,EACA,EACA,EACAhE,EACAC,GAEFsD,EAAkBjD,GA9BpB,6CAbsC,kEA8CtC,kCAAAzD,EAAA,sEACuCkH,EACnCxG,EACA6D,EACArB,EACAO,GALJ,mCACST,EADT,KACoBqE,EADpB,MAO8BtG,EACxB6F,EACAE,GACgBO,GACpB9C,EAAc6C,aACZpE,EACA,EACA,EACA,EACA,EACAoD,EACAC,GAlBJ,4CA9CsC,sBAoEtC,OACE,6BACE,kBAAClF,EAAA,EAAD,CACEG,QAAQ,kBACRD,UAAU,OACVE,QAAS,SAACzB,GAAD,OAzEuB,0CAyEZwH,CAAiBxH,KAHvC,oBAOA,kBAACqB,EAAA,EAAD,CACEG,QAAQ,kBACRD,UAAU,OACVE,QAAS,SAACzB,GAAD,OAhFuB,0CAgFZyH,CAAkBzH,KAHxC,cAOA,kBAACqB,EAAA,EAAD,CACEG,QAAQ,kBACRD,UAAU,OACVE,QAAS,SAACzB,I,8CAIR0H,CACE1H,EACAyE,EACA6B,EACAC,EACA3F,EAR0BK,EACxB6F,EACAE,KANR,W,MChBSW,MAjEf,SAAuBrI,GACrB,IAD4B,EAGwBqH,mBAAS,GAHjC,mBAGrBE,EAHqB,KAGDe,EAHC,OAI0BjB,mBAAS,GAJnC,mBAIrBI,EAJqB,KAIAD,EAJA,OAK4BH,mBAAS,GALrC,mBAKrBM,EALqB,KAKCD,EALD,OAMQL,mBAAS,WANjB,mBAMrBvD,EANqB,KAMTyE,EANS,KAQtBC,EAAuB,aAC3Bf,oBAAqB,CAACA,EAAqBD,GAC3CD,mBAAoB,CAACA,EAAoBe,GACzCX,qBAAsB,CAACA,EAAsBD,GAC7C5D,WAAYA,GACT9D,GAGCyI,EAAoB,CACxBzF,gBAAiBhD,EAAMgD,gBACvBE,gBAAiBlD,EAAMkD,iBAGzB,OACE,6BACE,6BACE,kBAAC,EAAD,CAAcvB,UAAW3B,EAAM2B,aAEjC,6BACE,kBAACvB,EAAA,EAAKsI,MAAN,iBACA,kBAACtI,EAAA,EAAKuI,QAAN,CACE1G,UAAU,gBACV3B,KAAK,QACLiC,MAAOuB,EACPrD,SAAU,SAACC,GAAD,ORvBpB,SAAsBA,EAAOkI,GAE3BA,EADkBlI,EAAMM,OAAhBuB,OQsBqBsG,CAAuBnI,EAAO6H,OAGvD,6BACE,kBAACnI,EAAA,EAAKsI,MAAN,oBAAyBnB,GACzB,kBAACnH,EAAA,EAAKuI,QAAN,CACE1G,UAAU,gBACV3B,KAAK,QACLwI,IAvCU,EAwCV9C,IAvCU,IAwCVzD,MAAOgF,EACP9G,SAAU,SAACC,GAAD,OAAW4H,EAAsB5H,EAAMM,OAAOuB,WAG5D,yBAAKN,UAAU,OACb,kBAAC,EAA4BuG,IAG/B,yBAAKvG,UAAU,OACb,kBAAC,EAAiBwG,IAGpB,6BACE,iDAAuBhB,GACvB,kDAAwBE,GACxB,kDACqBA,EAAuBF,M,MCjCrCN,MA9Bf,SAAgBnH,GACd,IAAMsB,EAAQtB,EAAMsB,MADC,EAEiBtB,EAAM4H,iBAApCZ,EAFa,EAEbA,YAAaC,EAFA,EAEAA,aAFA,EAGajH,EAAM+I,eAAhCC,EAHa,EAGbA,UAAWC,EAHE,EAGFA,WAHE,cAIqBjJ,EAAMmF,cAJ3B,GAIdA,EAJc,KAIC+D,EAJD,KAKfC,EAAYC,iBAAO,MAkBzB,OAhBAC,qBAAU,WAAO,IAETvC,EADsBqC,EAApBG,QACeC,WAAW,MAClCL,EAAiBpC,KAChB,IAEHuC,qBAAU,WACR,GAAa,MAAT/H,GAAkC,MAAjB6D,GAAsC,MAAbgE,EAA9C,CADc,IAIGK,EAAWL,EAApBG,QACRE,EAAO1J,MAAQkH,EACfwC,EAAOnE,OAAS4B,EAChB9B,EAAc4B,UAAUzF,EAAO,EAAG,EAAG0H,EAAWC,MAC/C,CAAC3H,EAAO0H,EAAWC,EAAYjC,EAAaC,IAG7C,6BACE,4BAAQwC,IAAKN,EAAWlH,UAAU,a,4CC3BxC,WAAiCvB,EAAOgJ,GAAxC,eAAA9I,EAAA,sEACsBiI,EAA4BnI,EAAOgJ,GADzD,OACQpI,EADR,OAEEoI,EAASpI,GAFX,4C,4BCwGeqI,MAjGf,WAAgB,IDKUC,EAAWC,ECLtB,EACaxC,mBAAS,IADtB,mBACN/F,EADM,KACCoI,EADD,OAEqBrC,oBAAS,GAF9B,mBAEN1F,EAFM,KAEKC,EAFL,OAGmCyF,mBAAS,MAH5C,mBAGNyC,EAHM,KAGYC,EAHZ,OAIqC1C,mBAAS,MAJ9C,mBAIN2C,EAJM,KAIaC,EAJb,OAMiC5C,mBAAS,GAN1C,mBAMNrE,EANM,KAMWC,EANX,OAOiCoE,mBAAS,GAP1C,mBAONnE,EAPM,KAOWC,EAPX,KASPrD,EDVCiG,KAAKC,IACVkE,SAASC,gBAAgBC,aAAe,EACxCC,OAAOC,YAAc,GCUjB1C,EAAmB,CACvB9H,MAAOA,EACPuF,QDRsBuE,ECKctI,EAAM+D,ODLTwE,ECKiBvI,EAAMxB,MDJlD8J,ECIyD9J,EDJ5B+J,ICU/BU,EAAiB,CACrBjJ,MAAOA,EACPsG,iBAAkB,CAChBZ,YAAaY,EAAiB9H,MAC9BmH,aAAcW,EAAiBvC,QAEjC0D,eAAgB,CACdC,UAAWpB,EAAiB9H,MAC5BmJ,WAAYrB,EAAiBvC,QAE/BF,cAAe,CAAC2E,EAAkBC,IAG9BS,EAAe,eAChBD,EADgB,CAEnBpF,cAAe,CAAC6E,EAAmBC,KAO/BQ,EAAqB,CACzBnJ,MAAO,CAACA,EAAOoI,GACf/H,UAAW,CAACA,EAAWC,GACvBuD,cAP2BxD,EACzB,CAACmI,EAAkBC,GACnB,CAACC,EAAmBC,GAMtBrC,iBAAkB,CAChBZ,YAAaY,EAAiB9H,MAC9BmH,aAAcW,EAAiBvC,QAEjCrC,gBAAiB,CAACA,EAAiBC,GACnCC,gBAAiB,CAACA,EAAiBC,IAGrC,OACE,yBAAKlB,UAAU,OACb,iDACA,6BACE,kBAAC,EAAWsI,IAEd,6BACE,kBAAC,EAAWC,IAEd,6BACE,kBAACE,EAAA,EAAD,CAAWC,iBAAiB,KAC1B,kBAACC,EAAA,EAAD,KACE,kBAACA,EAAA,EAAKC,OAAN,KACE,kBAACH,EAAA,EAAUI,OAAX,CAAkBC,GAAIhJ,IAAQG,QAAQ,OAAO8I,SAAS,KAAtD,mBAIF,kBAACN,EAAA,EAAUO,SAAX,CAAoBD,SAAS,KAC3B,kBAACJ,EAAA,EAAKM,KAAN,KACE,kBAAC,EAAD,CACEhL,OAAO,UACPD,MAAM,eACNE,gBAAiB,SAACO,GAAD,O,6CACf0H,CAAwB1H,EAAOgJ,SAMzC,kBAACkB,EAAA,EAAD,KACE,kBAACA,EAAA,EAAKC,OAAN,KACE,kBAACH,EAAA,EAAUI,OAAX,CAAkBC,GAAIhJ,IAAQG,QAAQ,OAAO8I,SAAS,KAAtD,sBAIF,kBAACN,EAAA,EAAUO,SAAX,CAAoBD,SAAS,KAC3B,kBAACJ,EAAA,EAAKM,KAAN,KACE,kBAAC,EAAkBT,UCnFfU,QACW,cAA7Bd,OAAOe,SAASC,UAEe,UAA7BhB,OAAOe,SAASC,UAEhBhB,OAAOe,SAASC,SAASC,MACvB,2D,MCXNC,IAASC,OAAO,kBAAC,EAAD,MAAStB,SAASuB,eAAe,SD4H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.53975dbd.chunk.js","sourcesContent":["import React from \"react\";\nimport { Form } from \"react-bootstrap\";\n\nfunction FileInput(props) {\n  const { label, accept, onChangeHandler } = props;\n  return (\n    <div>\n      <Form.File\n        type=\"file\"\n        accept={accept}\n        label={label}\n        style={inputStyle}\n        custom\n        onChange={(event) => onChangeHandler(event)}\n      />\n    </div>\n  );\n}\n\nconst inputStyle = {\n  width: \"300px\",\n};\n\nexport default FileInput;\n","/**\n * Return the image with it's source loaded from an file input\n * @param {*} event\n */\nasync function getImageFromInput(event) {\n  return new Promise((resolve, reject) => {\n    if (event.target.files && event.target.files.item(0)) {\n      const imageSource = URL.createObjectURL(event.target.files[0]);\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.src = imageSource;\n      return;\n    }\n    reject(\"No file selected\");\n  });\n}\n\nfunction setFromInput(event, setter) {\n  const { value } = event.target;\n  setter(value);\n}\n\nexport { getImageFromInput, setFromInput };\n","import { Button } from \"react-bootstrap\";\nimport React from \"react\";\nfunction ColorToggler(props) {\n  const [isRedEdit, setIsRedEdit] = props.isRedEdit;\n  const redToggler = () => {\n    setIsRedEdit((prev) => !prev);\n  };\n  return (\n    <div>\n      <div>Currently editing:</div>\n      <Button\n        active={isRedEdit}\n        className=\"mr-2\"\n        variant=\"outline-danger\"\n        onClick={redToggler}\n      >\n        Red\n      </Button>\n      <Button\n        active={!isRedEdit}\n        variant=\"outline-primary\"\n        onClick={redToggler}\n      >\n        Blue\n      </Button>\n    </div>\n  );\n}\n\nexport default ColorToggler;\n","function incrementBy(e, stateSetter, value) {\n  e.preventDefault();\n  stateSetter((previous) => previous + value);\n}\n\nfunction incrementOrginCoordinates(e, xIncrement, yIncrement, stateSetter) {\n  e.preventDefault();\n  stateSetter(({ x, y }) => {\n    return { x: x + xIncrement, y: y + yIncrement };\n  });\n}\n\nexport { incrementBy, incrementOrginCoordinates };\n","// TODO to be implemented / fixed\nimport React from \"react\";\nimport \"./index.css\";\nimport { incrementBy, incrementOrginCoordinates } from \"./utils\";\nimport { Button } from \"react-bootstrap\";\n\nfunction ImageAligner(props) {\n  const [rotationDegrees, setRotationDegrees] = props.rotationDegrees;\n  const [axisCoordinates, setAxisCoordinates] = props.axisCoordinates;\n  return (\n    <div>\n      <div>\n        <div>Axis offset Y:{axisCoordinates.y}</div>\n        <div>Move Vertical</div>\n        <Button\n          className=\"mx-1\"\n          onClick={(event) =>\n            incrementOrginCoordinates(event, 0, -1, setAxisCoordinates)\n          }\n        >\n          Move up\n        </Button>\n        <Button\n          className=\"mx-1\"\n          onClick={(event) =>\n            incrementOrginCoordinates(event, 0, 1, setAxisCoordinates)\n          }\n        >\n          Move down\n        </Button>\n      </div>\n\n      <div>\n        <div>Degrees of rotation: {rotationDegrees}</div>\n        <Button\n          className=\"mx-1\"\n          onClick={(event) => incrementBy(event, setRotationDegrees, -1)}\n        >\n          Rotate left\n        </Button>\n        <Button\n          className=\"mx-1\"\n          onClick={(event) => incrementBy(event, setRotationDegrees, 1)}\n        >\n          Rotate right\n        </Button>\n      </div>\n    </div>\n  );\n}\nexport default ImageAligner;\n","/**\n * Basic algorithm for red detection\n * @param {*} threshold\n */\nfunction isRed(threshold) {\n  return (r, g, b) => r * 2 - (g + b) > 255 - threshold;\n}\n\n/**\n * Basic algorithm for blue detection\n * @param {*} threshold\n */\nfunction isBlue(threshold) {\n  return (r, g, b) => b * 2 - (g + r) > 255 - threshold;\n}\n\n/**\n * Offsets access each value in a canvasContext.getImageData()\n */\nconst R_OFFSET = 0;\nconst G_OFFSET = 1;\nconst B_OFFSET = 2;\n\n/**\n * Detects the color, recolors it, and return the newly recolored image / number of pixels colored\n * @param {*} detectionDimensions\n * @param {*} imageData\n * @param {*} isColor\n * @param {*} recolorHex\n */\nasync function detect(detectionDimensions, imageData, isColor, recolorHex) {\n  const { detectionWidth, detectionHeight } = detectionDimensions;\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(recolorHex);\n  const detectedPixels = [];\n\n  const originalPixels = imageData.data.slice();\n\n  for (let y = 0; y < detectionHeight; y++) {\n    for (let x = 0; x < detectionWidth; x++) {\n      const redIndex = getIndex(x, y, detectionWidth) + R_OFFSET;\n      const greenIndex = getIndex(x, y, detectionWidth) + G_OFFSET;\n      const blueIndex = getIndex(x, y, detectionWidth) + B_OFFSET;\n\n      const redValue = originalPixels[redIndex];\n      const greenValue = originalPixels[greenIndex];\n      const blueValue = originalPixels[blueIndex];\n\n      if (isColor(redValue, greenValue, blueValue)) {\n        imageData.data[redIndex] = Number(redRecolor);\n        imageData.data[greenIndex] = Number(greenRecolor);\n        imageData.data[blueIndex] = Number(blueRecolor);\n        detectedPixels.push({ x: x, y: y });\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, detectedPixels]);\n}\n\n/**\n * Color the canvas area and return how many detected pixels there are\n * @param {*} param0\n * @param {*} canvasContext\n * @param {*} newColorHex\n * @param {*} detectedPixels\n */\nasync function colorArea(\n  { width, height },\n  canvasContext,\n  newColorHex,\n  detectedPixels\n) {\n  const [redRecolor, greenRecolor, blueRecolor] = hexToRgb(newColorHex);\n  const imageData = canvasContext.getImageData(0, 0, width, height);\n  let numPixelsColored = 0;\n  let maxY = 0;\n\n  const existingPixels = new Map();\n  const isExistingPixel = containsXYKeyIn(getXYKey, existingPixels);\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    maxY = Math.max(y, maxY);\n    const key = getXYKey(x, y);\n    existingPixels.set(key, null);\n    numPixelsColored++;\n  }\n\n  for (let coordinate of detectedPixels) {\n    const { x, y } = coordinate;\n    for (let i = y; i < maxY; i++) {\n      if (!isExistingPixel(x, i)) {\n        const redIndex = getIndex(x, i, width) + R_OFFSET;\n        const greenIndex = getIndex(x, i, width) + G_OFFSET;\n        const blueIndex = getIndex(x, i, width) + B_OFFSET;\n        imageData.data[redIndex] = redRecolor;\n        imageData.data[greenIndex] = greenRecolor;\n        imageData.data[blueIndex] = blueRecolor;\n\n        const key = getXYKey(x, i);\n        existingPixels.set(key, null);\n        numPixelsColored++;\n      }\n    }\n  }\n\n  return Promise.resolve([imageData, numPixelsColored]);\n}\n\n/**\n * Get the unique key given the arguments\n * @param {*} x\n * @param {*} y\n */\nfunction getXYKey(x, y) {\n  return String(x) + String(y);\n}\n\n/**\n * Given x,y is the generated key in this map?\n * @param {*} x\n * @param {*} y\n * @param {*} map\n */\nfunction containsXYKeyIn(getKey, map) {\n  return (x, y) => {\n    const key = getKey(x, y);\n    return map.has(key);\n  };\n}\n\n/**\n * #FFF 4 length hex or #FFFFFF 6 length to rgb\n * @param {*} hex\n */\nfunction hexToRgb(hex) {\n  let red = 0,\n    green = 0,\n    blue = 0;\n  if (hex.length == 4) {\n    red = \"0x\" + hex[1] + hex[1];\n    green = \"0x\" + hex[2] + hex[2];\n    blue = \"0x\" + hex[3] + hex[3];\n  } else if (hex.length == 7) {\n    red = \"0x\" + hex[1] + hex[2];\n    green = \"0x\" + hex[3] + hex[4];\n    blue = \"0x\" + hex[5] + hex[6];\n  }\n  return [red, green, blue];\n}\n\n/**\n * Get the index in a canvasContext.getImageData() array given the x, y, and width\n * @param {*} x\n * @param {*} y\n * @param {*} width\n */\nfunction getIndex(x, y, width) {\n  return (x + y * width) * 4;\n}\n\nexport { detect, colorArea, isRed, isBlue };\n","// TODO to be implemented / fixed!\n\nconst WIDTH_PADDING = 50;\n\nasync function drawRotated(context, canvas, degrees, image) {\n  if (canvas == null || image == null || context == null) {\n    return;\n  }\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.save();\n  context.translate(canvas.width / 2, canvas.height / 2);\n  context.rotate(degreesToRadians(degrees));\n\n  const width = window.innerWidth - WIDTH_PADDING;\n  const height = (image.height / width) * width;\n  context.drawImage(image, -width / 2, -height / 2);\n  context.restore();\n}\n\nfunction drawAxis(context, canvas, axisCoordinates, image) {\n  if (canvas == null || image == null) {\n    return;\n  }\n  const { x: xOffset, y: yOffset } = axisCoordinates;\n  const { width: canvasWidth, height: canvasHeight } = canvas;\n  const originX = 0;\n  const originY = canvasHeight / 2 + yOffset;\n  context.beginPath();\n  context.moveTo(originX, originY + yOffset);\n  context.lineTo(originX + canvasWidth, originY + yOffset);\n  context.strokeStyle = \"#FF0000\";\n  context.stroke();\n}\n\nfunction degreesToRadians(degrees) {\n  return degrees * 0.01745;\n}\n\nfunction clearCanvasDrawing(context, width, height) {\n  if (context == null) {\n    return;\n  }\n  context.clearRect(0, 0, width, height);\n}\n\nfunction setWithImage(context, width, height, image) {\n  if (context == null) {\n    return;\n  }\n  context.drawImage(image, 0, 0, width, height);\n}\n\nexport { drawRotated, drawAxis, clearCanvasDrawing, setWithImage };\n","import * as Canvas from \"../../utils/Canvas\";\n\nasync function resetCanvas(\n  event,\n  canvasContext,\n  canvasWidth,\n  canvasHeight,\n  image,\n  setNumPixelsColored\n) {\n  event.preventDefault();\n  Canvas.setWithImage(canvasContext, canvasWidth, canvasHeight, image);\n  setNumPixelsColored(0);\n}\n\nexport { resetCanvas };\n","import React, { useState } from \"react\";\nimport { Button } from \"react-bootstrap\";\nimport * as ImageAnalysis from \"../../utils/ImageAnalysis\";\nimport * as utils from \"./utils\";\n\nfunction CanvasEffectButtonGroup(props) {\n  const [detectedPixels, setDetectedPixels] = useState([]);\n  const { recolorHex } = props;\n  const [isRedEdit] = props.isRedEdit;\n\n  const [canvasContext] = props.canvasContext;\n  const [detectionThreshold] = props.detectionThreshold;\n  const [, setNumPixelsColoredRed] = props.numPixelsColoredRed;\n  const [, setNumPixelsColoredBlue] = props.numPixelsColoredBlue;\n\n  const [image] = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n\n  async function recolorDetection() {\n    const { width: detectionWidth, height: detectionHeight } = image;\n    const detectionDimensions = { detectionWidth, detectionHeight };\n    const imageData = canvasContext.getImageData(\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n\n    const isColorDetector = isRedEdit\n      ? ImageAnalysis.isRed(detectionThreshold)\n      : ImageAnalysis.isBlue(detectionThreshold);\n\n    const [recoloredImageData, detectedPixels] = await ImageAnalysis.detect(\n      detectionDimensions,\n      imageData,\n      isColorDetector,\n      recolorHex\n    );\n\n    canvasContext.putImageData(\n      recoloredImageData,\n      0,\n      0,\n      0,\n      0,\n      detectionWidth,\n      detectionHeight\n    );\n    setDetectedPixels(detectedPixels);\n  }\n\n  async function recolorCanvasArea() {\n    const [imageData, numPixels] = await ImageAnalysis.colorArea(\n      image,\n      canvasContext,\n      recolorHex,\n      detectedPixels\n    );\n    const setNumPixelsColored = isRedEdit\n      ? setNumPixelsColoredRed\n      : setNumPixelsColoredBlue;\n    setNumPixelsColored(numPixels);\n    canvasContext.putImageData(\n      imageData,\n      0,\n      0,\n      0,\n      0,\n      canvasWidth,\n      canvasHeight\n    );\n  }\n\n  return (\n    <div>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={(event) => recolorDetection(event)}\n      >\n        Recolor detected\n      </Button>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={(event) => recolorCanvasArea(event)}\n      >\n        Color area\n      </Button>\n      <Button\n        variant=\"outline-primary\"\n        className=\"mx-1\"\n        onClick={(event) => {\n          const setNumPixelsColored = isRedEdit\n            ? setNumPixelsColoredRed\n            : setNumPixelsColoredBlue;\n          utils.resetCanvas(\n            event,\n            canvasContext,\n            canvasWidth,\n            canvasHeight,\n            image,\n            setNumPixelsColored\n          );\n        }}\n      >\n        Reset\n      </Button>\n    </div>\n  );\n}\n\nexport default CanvasEffectButtonGroup;\n","import React, { useState } from \"react\";\nimport { Form } from \"react-bootstrap\";\nimport * as DomHelper from \"../../utils/DomHelper\";\nimport ColorToggler from \"../ColorToggler/ColorToggler\";\nimport ImageAligner from \"../ImageAligner/ImageAligner\";\nimport CanvasEffectButtonGroup from \"../../components/CanvasColorOptions/CanvasColorOptions\";\nimport \"./index.css\";\n\nfunction ImageAnalyzer(props) {\n  const sliderMin = 0;\n  const sliderMax = 255;\n  const [detectionThreshold, setDetectionThreshold] = useState(0);\n  const [numPixelsColoredRed, setNumPixelsColoredRed] = useState(0);\n  const [numPixelsColoredBlue, setNumPixelsColoredBlue] = useState(0);\n  const [recolorHex, setRecolorHex] = useState(\"#00FF00\");\n\n  const canvasColorOptionsProps = {\n    numPixelsColoredRed: [numPixelsColoredRed, setNumPixelsColoredRed],\n    detectionThreshold: [detectionThreshold, setDetectionThreshold],\n    numPixelsColoredBlue: [numPixelsColoredBlue, setNumPixelsColoredBlue],\n    recolorHex: recolorHex,\n    ...props,\n  };\n\n  const imageAlignerProps = {\n    rotationDegrees: props.rotationDegrees,\n    axisCoordinates: props.axisCoordinates,\n  };\n\n  return (\n    <div>\n      <div>\n        <ColorToggler isRedEdit={props.isRedEdit} />\n      </div>\n      <div>\n        <Form.Label>Recolor:</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"color\"\n          value={recolorHex}\n          onChange={(event) => DomHelper.setFromInput(event, setRecolorHex)}\n        />\n      </div>\n      <div>\n        <Form.Label>Sensitivity:{detectionThreshold}</Form.Label>\n        <Form.Control\n          className=\"mx-auto input\"\n          type=\"range\"\n          min={sliderMin}\n          max={sliderMax}\n          value={detectionThreshold}\n          onChange={(event) => setDetectionThreshold(event.target.value)}\n        />\n      </div>\n      <div className=\"m-2\">\n        <CanvasEffectButtonGroup {...canvasColorOptionsProps} />\n      </div>\n\n      <div className=\"m-2\">\n        <ImageAligner {...imageAlignerProps} />\n      </div>\n\n      <div>\n        <div>Red pixel count: {numPixelsColoredRed}</div>\n        <div>Blue pixel count: {numPixelsColoredBlue}</div>\n        <div>\n          Red / Blue ratio: {numPixelsColoredBlue / numPixelsColoredRed}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default ImageAnalyzer;\n","import React, { useEffect, useRef } from \"react\";\nimport \"./index.css\";\n\nfunction Canvas(props) {\n  const image = props.image;\n  const { canvasWidth, canvasHeight } = props.canvasDimensions;\n  const { drawWidth, drawHeight } = props.drawDimensions;\n  const [canvasContext, setCanvasContext] = props.canvasContext;\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    const context = canvas.getContext(\"2d\");\n    setCanvasContext(context);\n  }, []);\n\n  useEffect(() => {\n    if (image == null || canvasContext == null || canvasRef == null) {\n      return;\n    }\n    const { current: canvas } = canvasRef;\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvasContext.drawImage(image, 0, 0, drawWidth, drawHeight);\n  }, [image, drawWidth, drawHeight, canvasWidth, canvasHeight]);\n\n  return (\n    <div>\n      <canvas ref={canvasRef} className=\"border\" />\n    </div>\n  );\n}\n\nexport default Canvas;\n","import * as DomHelper from \"../../utils/DomHelper\";\nasync function saveSelectedImage(event, setImage) {\n  const image = await DomHelper.getImageFromInput(event, setImage);\n  setImage(image);\n}\n\nfunction getCurrentViewportWidth() {\n  return Math.max(\n    document.documentElement.clientWidth || 0,\n    window.innerWidth || 0\n  );\n}\n\nfunction getProportionalX(originalX, originalY, proportionalY) {\n  return (originalX * proportionalY) / originalY;\n}\n\nexport { saveSelectedImage, getCurrentViewportWidth, getProportionalX };\n","import React, { useState } from \"react\";\nimport { Button, Card, Accordion } from \"react-bootstrap\";\nimport FileInput from \"../FileInput/FileInput\";\nimport ImageAnalyzer from \"../ImageAnalyzer/ImageAnalyzer\";\nimport Canvas from \"../Canvas/Canvas\";\nimport * as utils from \"./utils\";\nimport \"./App.css\";\n\nfunction App() {\n  const [image, setImage] = useState({});\n  const [isRedEdit, setIsRedEdit] = useState(true);\n  const [canvasContextRed, setCanvasContextRed] = useState(null);\n  const [canvasContextBlue, setCanvasContextBlue] = useState(null);\n\n  const [rotationDegrees, setRotationDegrees] = useState(0);\n  const [axisCoordinates, setAxisCoordinates] = useState(0);\n\n  const width = utils.getCurrentViewportWidth();\n  const height = utils.getProportionalX(image.height, image.width, width);\n  const canvasDimensions = {\n    width: width,\n    height: height,\n  };\n\n  const redCanvasProps = {\n    image: image,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    drawDimensions: {\n      drawWidth: canvasDimensions.width,\n      drawHeight: canvasDimensions.height,\n    },\n    canvasContext: [canvasContextRed, setCanvasContextRed],\n  };\n\n  const blueCanvasProps = {\n    ...redCanvasProps,\n    canvasContext: [canvasContextBlue, setCanvasContextBlue],\n  };\n\n  const currentCanvasContext = isRedEdit\n    ? [canvasContextRed, setCanvasContextRed]\n    : [canvasContextBlue, setCanvasContextBlue];\n\n  const imageAnalyzerProps = {\n    image: [image, setImage],\n    isRedEdit: [isRedEdit, setIsRedEdit],\n    canvasContext: currentCanvasContext,\n    canvasDimensions: {\n      canvasWidth: canvasDimensions.width,\n      canvasHeight: canvasDimensions.height,\n    },\n    rotationDegrees: [rotationDegrees, setRotationDegrees],\n    axisCoordinates: [axisCoordinates, setAxisCoordinates],\n  };\n\n  return (\n    <div className=\"App\">\n      <h4>Welcome to G-calc</h4>\n      <div>\n        <Canvas {...redCanvasProps} />\n      </div>\n      <div>\n        <Canvas {...blueCanvasProps} />\n      </div>\n      <div>\n        <Accordion defaultActiveKey=\"0\">\n          <Card>\n            <Card.Header>\n              <Accordion.Toggle as={Button} variant=\"link\" eventKey=\"0\">\n                1. Image input\n              </Accordion.Toggle>\n            </Card.Header>\n            <Accordion.Collapse eventKey=\"0\">\n              <Card.Body>\n                <FileInput\n                  accept=\"image/*\"\n                  label=\"Choose image\"\n                  onChangeHandler={(event) =>\n                    utils.saveSelectedImage(event, setImage)\n                  }\n                />\n              </Card.Body>\n            </Accordion.Collapse>\n          </Card>\n          <Card>\n            <Card.Header>\n              <Accordion.Toggle as={Button} variant=\"link\" eventKey=\"1\">\n                2. Image analysis\n              </Accordion.Toggle>\n            </Card.Header>\n            <Accordion.Collapse eventKey=\"1\">\n              <Card.Body>\n                <ImageAnalyzer {...imageAnalyzerProps} />\n              </Card.Body>\n            </Accordion.Collapse>\n          </Card>\n        </Accordion>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"../src/components/App/App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}